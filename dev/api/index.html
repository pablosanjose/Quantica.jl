<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Quantica.jl</title><meta name="title" content="API · Quantica.jl"/><meta property="og:title" content="API · Quantica.jl"/><meta property="twitter:title" content="API · Quantica.jl"/><meta name="description" content="Documentation for Quantica.jl."/><meta property="og:description" content="Documentation for Quantica.jl."/><meta property="twitter:description" content="Documentation for Quantica.jl."/><meta property="og:url" content="https://pablosanjose.github.io/Quantica.jl/api/"/><meta property="twitter:url" content="https://pablosanjose.github.io/Quantica.jl/api/"/><link rel="canonical" href="https://pablosanjose.github.io/Quantica.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="Quantica.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Quantica.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Quantica.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../tutorial/tutorial/">Welcome</a></li><li><a class="tocitem" href="../tutorial/glossary/">Glossary</a></li><li><a class="tocitem" href="../tutorial/lattices/">Lattices</a></li><li><a class="tocitem" href="../tutorial/models/">Models</a></li><li><a class="tocitem" href="../tutorial/hamiltonians/">Hamiltonians</a></li><li><a class="tocitem" href="../tutorial/bandstructures/">Bandstructures</a></li><li><a class="tocitem" href="../tutorial/greenfunctions/">GreenFunctions</a></li><li><a class="tocitem" href="../tutorial/observables/">Observables</a></li></ul></li><li><span class="tocitem">Advanced</span><ul><li><a class="tocitem" href="../advanced/nonspatial/">Non-spatial models</a></li><li><a class="tocitem" href="../advanced/serializers/">Serializers</a></li><li><a class="tocitem" href="../advanced/meanfield/">Self-consistent mean fields</a></li><li><a class="tocitem" href="../advanced/wannier90/">Wannier90 imports</a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/pablosanjose/Quantica.jl/blob/master/docs/src/api.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="api"><a class="docs-heading-anchor" href="#api">API</a><a id="api-1"></a><a class="docs-heading-anchor-permalink" href="#api" title="Permalink"></a></h1><ul><li><a href="#Quantica.EigenSolvers"><code>Quantica.EigenSolvers</code></a></li><li><a href="#Quantica.ExternalPresets"><code>Quantica.ExternalPresets</code></a></li><li><a href="#Quantica.GreenSolvers"><code>Quantica.GreenSolvers</code></a></li><li><a href="#Quantica.HamiltonianPresets"><code>Quantica.HamiltonianPresets</code></a></li><li><a href="#Quantica.LatticePresets"><code>Quantica.LatticePresets</code></a></li><li><a href="#Quantica.Paths"><code>Quantica.Paths</code></a></li><li><a href="#Quantica.RegionPresets"><code>Quantica.RegionPresets</code></a></li><li><a href="#Quantica.zerofield"><code>Quantica.zerofield</code></a></li><li><a href="#Quantica.BoxIterator"><code>Quantica.BoxIterator</code></a></li><li><a href="#Quantica.OrbitalSliceArray"><code>Quantica.OrbitalSliceArray</code></a></li><li><a href="#Quantica.OrbitalSliceMatrix"><code>Quantica.OrbitalSliceMatrix</code></a></li><li><a href="#Quantica.OrbitalSliceVector"><code>Quantica.OrbitalSliceVector</code></a></li><li><a href="#Base.position"><code>Base.position</code></a></li><li><a href="#Base.reverse"><code>Base.reverse</code></a></li><li><a href="#Base.reverse!"><code>Base.reverse!</code></a></li><li><a href="#LinearAlgebra.ishermitian"><code>LinearAlgebra.ishermitian</code></a></li><li><a href="#Quantica.ExternalPresets.wannier90"><code>Quantica.ExternalPresets.wannier90</code></a></li><li><a href="#Quantica.attach"><code>Quantica.attach</code></a></li><li><a href="#Quantica.bands"><code>Quantica.bands</code></a></li><li><a href="#Quantica.bravais_matrix"><code>Quantica.bravais_matrix</code></a></li><li><a href="#Quantica.combine"><code>Quantica.combine</code></a></li><li><a href="#Quantica.conductance"><code>Quantica.conductance</code></a></li><li><a href="#Quantica.current"><code>Quantica.current</code></a></li><li><a href="#Quantica.decay_lengths"><code>Quantica.decay_lengths</code></a></li><li><a href="#Quantica.densitymatrix"><code>Quantica.densitymatrix</code></a></li><li><a href="#Quantica.deserialize"><code>Quantica.deserialize</code></a></li><li><a href="#Quantica.deserialize!"><code>Quantica.deserialize!</code></a></li><li><a href="#Quantica.diagonal"><code>Quantica.diagonal</code></a></li><li><a href="#Quantica.energies"><code>Quantica.energies</code></a></li><li><a href="#Quantica.gap"><code>Quantica.gap</code></a></li><li><a href="#Quantica.gaps"><code>Quantica.gaps</code></a></li><li><a href="#Quantica.greenfunction"><code>Quantica.greenfunction</code></a></li><li><a href="#Quantica.hamiltonian"><code>Quantica.hamiltonian</code></a></li><li><a href="#Quantica.hopping"><code>Quantica.hopping</code></a></li><li><a href="#Quantica.hopselector"><code>Quantica.hopselector</code></a></li><li><a href="#Quantica.integrand"><code>Quantica.integrand</code></a></li><li><a href="#Quantica.josephson"><code>Quantica.josephson</code></a></li><li><a href="#Quantica.lattice"><code>Quantica.lattice</code></a></li><li><a href="#Quantica.ldos"><code>Quantica.ldos</code></a></li><li><a href="#Quantica.meanfield"><code>Quantica.meanfield</code></a></li><li><a href="#Quantica.neighbors"><code>Quantica.neighbors</code></a></li><li><a href="#Quantica.onsite"><code>Quantica.onsite</code></a></li><li><a href="#Quantica.orbaxes"><code>Quantica.orbaxes</code></a></li><li><a href="#Quantica.plusadjoint"><code>Quantica.plusadjoint</code></a></li><li><a href="#Quantica.points"><code>Quantica.points</code></a></li><li><a href="#Quantica.serialize"><code>Quantica.serialize</code></a></li><li><a href="#Quantica.serialize!"><code>Quantica.serialize!</code></a></li><li><a href="#Quantica.serializer"><code>Quantica.serializer</code></a></li><li><a href="#Quantica.siteindexdict"><code>Quantica.siteindexdict</code></a></li><li><a href="#Quantica.sitepairs"><code>Quantica.sitepairs</code></a></li><li><a href="#Quantica.sites"><code>Quantica.sites</code></a></li><li><a href="#Quantica.siteselector"><code>Quantica.siteselector</code></a></li><li><a href="#Quantica.spectrum"><code>Quantica.spectrum</code></a></li><li><a href="#Quantica.states"><code>Quantica.states</code></a></li><li><a href="#Quantica.stitch"><code>Quantica.stitch</code></a></li><li><a href="#Quantica.subdiv"><code>Quantica.subdiv</code></a></li><li><a href="#Quantica.sublat"><code>Quantica.sublat</code></a></li><li><a href="#Quantica.supercell"><code>Quantica.supercell</code></a></li><li><a href="#Quantica.transform"><code>Quantica.transform</code></a></li><li><a href="#Quantica.translate"><code>Quantica.translate</code></a></li><li><a href="#Quantica.transmission"><code>Quantica.transmission</code></a></li><li><a href="#Quantica.unflat"><code>Quantica.unflat</code></a></li><li><a href="#Quantica.σ"><code>Quantica.σ</code></a></li><li><a href="#Quantica.@hopping"><code>Quantica.@hopping</code></a></li><li><a href="#Quantica.@hopping!"><code>Quantica.@hopping!</code></a></li><li><a href="#Quantica.@onsite"><code>Quantica.@onsite</code></a></li><li><a href="#Quantica.@onsite!"><code>Quantica.@onsite!</code></a></li><li><a href="#Quantica.@stitch"><code>Quantica.@stitch</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.EigenSolvers" href="#Quantica.EigenSolvers"><code>Quantica.EigenSolvers</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>EigenSolvers</code> is a Quantica submodule containing support for several pre-defined eigensolver extensions. The alias <code>ES</code> can be used in place of <code>EigenSolvers</code>. Currently supported solvers are</p><pre><code class="nohighlight hljs">ES.LinearAlgebra(; kw...)       # Uses `eigen(mat; kw...)` from the `LinearAlgebra` package
ES.Arpack(; kw...)              # Uses `eigs(mat; kw...)` from the `Arpack` package (WARNING: Arpack is not thread-safe)
ES.KrylovKit(params...; kw...)  # Uses `eigsolve(mat, params...; kw...)` from the `KrylovKit` package
ES.ArnoldiMethod(; kw...)       # Uses `partialschur(mat; kw...)` from the `ArnoldiMethod` package.</code></pre><p>To use each of these solvers the corresponding package must be loaded with e.g. <code>using ArnoldiMethod</code>. The exception is the default <code>ES.LinearAlgebra</code> which is a direct Quantica dependency and does not require loading.</p><p>Additionally, to compute interior eigenvalues, we can use a shift-invert method around energy <code>ϵ0</code> (uses <code>LinearMaps</code> and a <code>LinearAlgebra.lu</code> factorization), combined with any solver <code>s</code> from the list above:</p><pre><code class="nohighlight hljs">ES.ShiftInvert(s, ϵ0)           # Perform a lu-based shift-invert with solver `s`</code></pre><p>The <code>ShiftInvert</code> solver extension requires doing <code>using LinearMaps</code>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; using LinearMaps, ArnoldiMethod  # loads required extensions

julia&gt; h = HP.graphene(t0 = 1) |&gt; supercell(10);

julia&gt; spectrum(h, (0,0); solver = ES.ShiftInvert(ES.ArnoldiMethod(nev = 4), 0.0)) |&gt; energies
4-element Vector{ComplexF64}:
 -0.3819660112501042 + 2.407681231060336e-16im
 -0.6180339887498942 - 2.7336317916863215e-16im
  0.6180339887498937 - 1.7243387890744497e-16im
  0.3819660112501042 - 1.083582785131051e-16im</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`spectrum`, `bands`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL1304-L1343">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.ExternalPresets" href="#Quantica.ExternalPresets"><code>Quantica.ExternalPresets</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>ExternalPresets</code> is a Quantica submodule containing utilities to import objects from external applications The alias <code>EP</code> can be used in place of <code>ExternalPresets</code>. Currently supported importers are</p><pre><code class="nohighlight hljs">EP.wannier90(args...; kw...)</code></pre><p>For details on the arguments <code>args</code> and keyword arguments <code>kw</code> see the docstring for the corresponding function.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`LatticePresets`, `RegionPresets`, `HamiltonianPresets`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL105-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.GreenSolvers" href="#Quantica.GreenSolvers"><code>Quantica.GreenSolvers</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>GreenSolvers</code> is a Quantica submodule containing several pre-defined Green function solvers. The alias <code>GS</code> can be used in place of <code>GS</code>. Currently supported solvers and their possible keyword arguments are</p><ul><li><code>GS.SparseLU()</code> : Direct inversion solver for 0D Hamiltonians using a <code>SparseArrays.lu(hmat)</code> factorization</li><li><code>GS.Spectrum(; spectrum_kw...)</code> : Diagonalization solver for 0D AbstractHamiltonians using <code>spectrum(h; spectrum_kw...)</code><ul><li><code>spectrum_kw...</code> : keyword arguments passed on to <code>spectrum</code></li><li>Contact self-energies are supported, even if they depend on parameters.</li><li>For Green functions of <code>h::ParametricHamiltonian</code>s, the spectrum of <code>h</code> for given parameters is computed on each call to <code>g(ω; params...)</code>. This is suboptimal if we want to scan <code>ω</code> for fixed <code>params</code>. In such case consider doing <code>g´ = g(; params...)</code> (this evaluates the spectrum once) and then <code>g´(ω)</code> in your ω-loop.</li></ul></li><li><code>GS.Schur(; boundary = Inf, axis = 1, integrate_opts...)</code> : Solver for 1D and 2D Hamiltonians based on a deflated, generalized Schur factorization and (possibly) integration over the Brillouin zone.<ul><li><code>boundary</code> : 1D cell index of a boundary cell, or <code>Inf</code> for no boundaries. Equivalent to removing that specific cell from the lattice when computing the Green function.</li><li>If the system is 2D, the wavevector along the transverse axis (the one different from the 1D <code>axis</code> given in the options) is numerically integrated using QuadGK with options given by <code>integrate_opts</code>, which is <code>(; atol = 1e-7)</code> by default.</li><li><code>integrate_opts</code> can also contain a <code>callback = f</code>, where <code>f</code> is a function that will be called <code>f(ϕs..., y)</code> at each point in the momentum integration. Here <code>ϕs</code> is the integration point in the Brillouin zone and <code>y</code> is the integrand evaluated at that point. Useful for inspection and debugging, e.g. <code>callback(x, y) = @show x</code>. Default: <code>Returns(nothing)</code>.</li></ul></li><li><code>GS.KPM(; order = 100, bandrange = missing, kernel = I)</code> : Kernel polynomial method solver for 0D Hamiltonians<ul><li><code>order</code> : order of the expansion in Chebyshev polynomials <code>Tₙ(h)</code> of the Hamiltonian <code>h</code> (lowest possible order is <code>n = 0</code>).</li><li><code>bandrange</code> : a <code>(min_energy, max_energy)::Tuple</code> interval that encompasses the full band of the Hamiltonian. If <code>missing</code>, it is computed automatically, but <code>using ArnoldiMethod</code> is required first.</li><li><code>kernel</code> : generalization that computes momenta as <code>μₙ = Tr[Tₙ(h)*kernel]</code>, so that the local density of states (see <code>ldos</code>) becomes the density of the <code>kernel</code> operator.</li><li>This solver does not allow arbitrary indexing of the resulting <code>g::GreenFunction</code>, only on contacts <code>g[contact_ind::Integer]</code>. If the system has none, we can add a dummy contact using <code>attach(h, nothing; sites...)</code>, see <code>attach</code>.</li></ul></li><li><code>GS.Bands(bands_arguments; boundary = missing, bands_kw...)</code>: solver based on the integration of bandstructure simplices<ul><li><code>bands_arguments</code>: positional arguments passed on to <code>bands</code></li><li><code>bands_kw</code>: keyword arguments passed on to <code>bands</code></li><li><code>boundary</code>: either <code>missing</code> (no boundary), or <code>dir =&gt; cell_pos</code> (single boundary), where <code>dir::Integer</code> is the Bravais vector normal to the boundary, and <code>cell_pos::Integer</code> the value of cell indices <code>cells[dir]</code> that define the boundary (i.e. <code>cells[dir] &lt;= cell_pos</code> are vaccum)</li><li>This solver only allows zero or one boundary. WARNING: if a boundary is used, the algorithm may become unstable for very fine band meshes.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL1769-L1795">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.HamiltonianPresets" href="#Quantica.HamiltonianPresets"><code>Quantica.HamiltonianPresets</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>HamiltonianPresets</code> is a Quantica submodule containing several pre-defined Hamiltonians. The alias <code>HP</code> can be used in place of <code>HamiltonianPresets</code>. Currently supported hamiltonians are</p><pre><code class="nohighlight hljs">HP.graphene(; kw...)
HP.twisted_bilayer_graphene(; kw...)</code></pre><p>For details on the keyword arguments <code>kw</code> see the corresponding docstring</p><pre><code class="language-julia-repl hljs">julia&gt; HamiltonianPresets.twisted_bilayer_graphene(twistindices = (30, 1))
Hamiltonian{Float64,3,2}: Hamiltonian on a 2D Lattice in 3D space
  Bloch harmonics  : 7
  Harmonic size    : 11164 × 11164
  Orbitals         : [1, 1, 1, 1]
  Element type     : scalar (ComplexF64)
  Onsites          : 0
  Hoppings         : 315684
  Coordination     : 28.27696</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`LatticePresets`, `RegionPresets`, `ExternalPresets`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL40-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.LatticePresets" href="#Quantica.LatticePresets"><code>Quantica.LatticePresets</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>LatticePresets</code> is a Quantica submodule containing several pre-defined lattices. The alias <code>LP</code> can be used in place of <code>LatticePresets</code>. Currently supported lattices are</p><pre><code class="nohighlight hljs">LP.linear(; a0 = 1, kw...)      # linear lattice in 1D
LP.square(; a0 = 1, kw...)      # square lattice in 2D
LP.triangular(; a0 = 1, kw...)  # triangular lattice in 2D
LP.honeycomb(; a0 = 1, kw...)   # honeycomb lattice in 2D
LP.cubic(; a0 = 1, kw...)       # cubic lattice in 3D
LP.fcc(; a0 = 1, kw...)         # face-centered-cubic lattice in 3D
LP.bcc(; a0 = 1, kw...)         # body-centered-cubic lattice in 3D
LP.hcp(; a0 = 1, kw...)         # hexagonal-closed-packed lattice in 3D</code></pre><p>In all cases <code>a0</code> denotes the lattice constant, and <code>kw...</code> are extra keywords forwarded to <code>lattice</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; LatticePresets.honeycomb(names = (:C, :D))
Lattice{Float64,2,2} : 2D lattice in 2D space
  Bravais vectors : [[0.5, 0.866025], [-0.5, 0.866025]]
  Sublattices     : 2
    Names         : (:C, :D)
    Sites         : (1, 1) --&gt; 2 total per unit cell

julia&gt; LatticePresets.cubic(bravais = ((1, 0), (0, 2)))
Lattice{Float64,3,2} : 2D lattice in 3D space
  Bravais vectors : [[1.0, 0.0, 0.0], [0.0, 2.0, 0.0]]
  Sublattices     : 1
    Names         : (:A,)
    Sites         : (1,) --&gt; 1 total per unit cell</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`RegionPresets`, `HamiltonianPresets`, `ExternalPresets`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL1-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.Paths" href="#Quantica.Paths"><code>Quantica.Paths</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Paths</code></pre><p>A Quantica submodule that contains representations of different integration paths in the complex-ω plane for integrals of the form <code>∫f(ω)g(ω)dω</code>, where <code>f(ω)</code> is the Fermi distribution at chemical potential <code>µ</code> and temperature <code>kBT</code>. Available paths are:</p><pre><code class="nohighlight hljs">Paths.radial(ωscale::Real, ϕ)</code></pre><p>A four-segment path from <code>ω = -Inf</code> to <code>ω = Inf</code>. The path first ascends along an arc of angle <code>ϕ</code> (with <code>0 &lt;= ϕ &lt; π/2</code>) and infinite radius. It then converges along a straight line in the second <code>ω-µ</code> quadrant to the chemical potential origin <code>ω = µ</code>. Finally it performs the mirror-symmetric itinerary in the first <code>ω-µ</code> quadrant, ending on the real axis at <code>ω = Inf</code>. The radial segments are traversed at a rate dictated by <code>ωscale</code>, that should represent some relevant energy scale in the system for optimal convergence of integrals. At zero temperature <code>kBT = 0</code>, the two last segments don&#39;t contribute and are elided.</p><pre><code class="nohighlight hljs">Paths.sawtooth(ωpoints...; slope = 1, imshift = true)</code></pre><p>A path connecting all points in the <code>ωpoints</code> collection (should all be real), but departing between each two into the complex plane and back with the given <code>slope</code>, forming a sawtooth path. Note that an extra point <code>µ</code> is added to the collection, where <code>µ</code> is the chemical potential, and the <code>real(ω)&gt;µ</code> segments are elided at zero temperatures. If <code>imshift = true</code> all <code>ωpoints</code> (of type <code>T&lt;:Real</code>) are shifted by <code>sqrt(eps(T))</code> to avoid the real axis.</p><pre><code class="nohighlight hljs">Paths.sawtooth(ωmax::Real; kw...)</code></pre><p>As above with <code>ωpoints = (-ωmax, ωmax)</code>.</p><pre><code class="nohighlight hljs">Paths.polygon(ωpoints...)</code></pre><p>A general polygonal path connecting <code>ωpoints</code>, which can be any collection of real or complex numbers</p><pre><code class="nohighlight hljs">Paths.polygon(ωfunc::Function)</code></pre><p>A ageneral polygonal path connecting <code>ωpoints = ωfunc(µ, kBT; params...)</code>. This is useful when the desired integration path depends on the chemical potential <code>µ</code>, temperature <code>kBT</code> or other system parameters <code>params</code>.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`densitymatrix`, `josephson`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL2289-L2331">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.RegionPresets" href="#Quantica.RegionPresets"><code>Quantica.RegionPresets</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>RegionPresets</code> is a Quantica submodule containing several pre-defined regions of type <code>Region{E}</code>, where <code>E</code> is the space dimension. The alias <code>RP</code> can be used in place of <code>RegionPresets</code>. Supported regions are</p><pre><code class="nohighlight hljs">RP.circle(radius = 10, center = (0, 0))                         # 2D
RP.ellipse((rx, ry) = (10, 15), center = (0, 0))                # 2D
RP.square(side = 10, center = (0, 0))                           # 2D
RP.rectangle((sx, sy) = (10, 15), center = (0, 0))              # 2D
RP.sphere(radius = 10, center = (0, 0, 0))                      # 3D
RP.spheroid((rx, ry, rz) = (10, 15, 20), center = (0, 0, 0))    # 3D
RP.cube(side = 10, center = (0, 0, 0))                          # 3D
RP.cuboid((sx, sy, sz) = (10, 15, 20), center = (0, 0, 0))      # 3D</code></pre><p>Calling a <code>f::Region{E}</code> object on a <code>r::Tuple</code> or <code>r::SVector</code> with <code>f(r)</code> or <code>f(r...)</code> returns <code>true</code> or <code>false</code> if <code>r</code> is inside the region or not. Note that only the first <code>E</code> coordinates of <code>r</code> will be checked. Arbitrary boolean functions can also be wrapped in <code>Region{E}</code> to create custom regions, e.g. <code>f = Region{2}(r -&gt; r[1]^2 &lt; r[2])</code>.</p><p>Boolean combinations of <code>Regions</code> are supported using <code>&amp;</code>, <code>|</code>, <code>xor</code> and <code>!</code> operators, such as <code>annulus = RP.circle(10) &amp; !RP.circle(5)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; RegionPresets.circle(10)(20, 0, 0)
false

julia&gt; RegionPresets.circle(10)(0, 0, 20)
true</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`LatticePresets`, `HamiltonianPresets`, `ExternalPresets`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL68-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.zerofield" href="#Quantica.zerofield"><code>Quantica.zerofield</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    zerofield</code></pre><p>An sigleton of type <code>ZeroField</code> that represents a zero-valued field. It has the property that it returns zero no matter how it is indexed (<code>zerofield[inds...] = 0.0 * I</code>), so it is useful as a default value in a non-spatial model involving mean fields. See <code>meanfield</code> for a usage example.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`meanfield`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL2831-L2842">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.BoxIterator" href="#Quantica.BoxIterator"><code>Quantica.BoxIterator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoxIterator(seed::SVector{N,Int}; maxiterations = TOOMANYITERS)</code></pre><p>Cartesian iterator <code>iter</code> over <code>SVector{N,Int}</code>s (<code>cell</code>s) that starts at <code>seed</code> and grows outwards in the form of a box of increasing sides (not necesarily equal) until it encompasses a certain N-dimensional region. To signal that a cell is in the desired region the user calls <code>acceptcell!(iter, cell)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/iterators.jl#LL5-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.OrbitalSliceArray" href="#Quantica.OrbitalSliceArray"><code>Quantica.OrbitalSliceArray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OrbitalSliceArray &lt;: AbstractArray</code></pre><p>A type of <code>AbstractArray</code> defined over a set of orbitals (see also <code>orbaxes</code>). It wraps a regular array that can be obtained with <code>parent(::OrbitalSliceArray)</code>, and supports all the general AbstractArray interface. In addition, it also supports indexing using <code>siteselector</code>s and <code>cellindices</code>. <code>OrbitalSliceVector</code> and <code>OrbitalSliceMatrix</code> are special cases of <code>OrbitalSliceArray</code> of dimension 1 and 2 respectively.</p><p>This is the common output type produced by <code>GreenFunctions</code> and most observables.</p><p>Note that for <code>m::OrbitalSliceMatrix</code>, <code>mat[i]</code> is equivalent to <code>mat[i,i]</code>, and <code>mat[; sel...]</code> is equivalent to <code>mat[(; sel...), (; sel...)]</code>.</p><p><strong><code>siteselector</code> indexing</strong></p><pre><code class="nohighlight hljs">mat[(; rowsites...), (; colsites...)]
mat[rowsel::SiteSelector, colsel::SiteSelector]</code></pre><p>If we index an <code>OrbitalSliceMatrix</code> with <code>s::NamedTuple</code> or a <code>siteselector(; s...)</code>, we obtain a new <code>OrbitalSliceMatrix</code> over the orbitals of the selected sites.</p><p><strong><code>sites</code> indexing</strong></p><pre><code class="nohighlight hljs">mat[sites(cell_index, site_indices)]
mat[sites(row_cell_index, row_site_indices), sites(col_cell_index, col_site_indices)]</code></pre><p>If we index an <code>OrbitalSliceMatrix</code> with <code>sites</code>, we obtain an unwrapped <code>Matrix</code> over the sites with <code>site_indices</code> within cell with <code>cell_index</code>. Here <code>site_indices</code> can be an <code>Int</code>, a container of <code>Int</code>, or a <code>:</code> (for all sites in the unit cell). If any of the specified sites are not already in <code>orbaxes(mat)</code>, indexing will throw an error.</p><p>Note that in this case we do not obtain a new <code>OrbitalSliceMatrix</code>. This behavior is required for performance, as re-wrapping in a new <code>OrbitalSliceMatrix</code> requires recomputing and allocating the new <code>orbaxes</code>.</p><pre><code class="nohighlight hljs">view(mat, rows::CellSites, cols::Cellsites = rows)</code></pre><p>Like the above, but returns a view instead of a copy of the indexed orbital matrix.</p><p>Note: <code>diagonal</code> indexing is currently not supported by <code>OrbitalSliceArray</code>.</p><p><strong><code>unflat</code> conversion</strong></p><pre><code class="nohighlight hljs">unflat(mat)</code></pre><p>Convert a <code>mat::OrbitalSliceMatrix</code> (or an <code>OrbitalSliceArray</code> in general) to an array of site blocks, where each block is a view into the original <code>mat</code>.</p><pre><code class="nohighlight hljs">unflat(SMatrix{N,N}, mat)</code></pre><p>Like the above but converting each block view into an NxN SMatrix, see <code>unflat</code> for details.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; g = LP.linear() |&gt; hamiltonian(hopping(SA[0 1; 1 0]) + onsite(I), orbitals = 2) |&gt; supercell(4) |&gt; greenfunction;

julia&gt; mat = g(0.2)[region = r -&gt; 2&lt;=r[1]&lt;=4]
6×6 OrbitalSliceMatrix{ComplexF64,Matrix{ComplexF64}}:
 -1.93554e-9-0.545545im          0.0-0.0im               0.0-0.0im              -0.5+0.218218im          0.4+0.37097im           0.0+0.0im
         0.0-0.0im       -1.93554e-9-0.545545im         -0.5+0.218218im          0.0-0.0im               0.0+0.0im               0.4+0.37097im
         0.0-0.0im              -0.5+0.218218im  -1.93554e-9-0.545545im          0.0-0.0im               0.0+0.0im              -0.5+0.218218im
        -0.5+0.218218im          0.0-0.0im               0.0-0.0im       -1.93554e-9-0.545545im         -0.5+0.218218im          0.0+0.0im
         0.4+0.37097im           0.0+0.0im               0.0+0.0im              -0.5+0.218218im  -1.93554e-9-0.545545im          0.0-0.0im
         0.0+0.0im               0.4+0.37097im          -0.5+0.218218im          0.0+0.0im               0.0-0.0im       -1.93554e-9-0.545545im

julia&gt; mat[(; cells = SA[1]), (; cells = SA[0])]
2×4 OrbitalSliceMatrix{ComplexF64,Matrix{ComplexF64}}:
 0.4+0.37097im  0.0+0.0im       0.0+0.0im       -0.5+0.218218im
 0.0+0.0im      0.4+0.37097im  -0.5+0.218218im   0.0+0.0im

julia&gt; mat[sites(SA[1], 1)]
2×2 Matrix{ComplexF64}:
 -1.93554e-9-0.545545im          0.0-0.0im
         0.0-0.0im       -1.93554e-9-0.545545im</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`siteselector`, `cellindices`, `orbaxes`, `unflat`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL2335-L2415">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.OrbitalSliceMatrix" href="#Quantica.OrbitalSliceMatrix"><code>Quantica.OrbitalSliceMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OrbitalSliceArray &lt;: AbstractArray</code></pre><p>A type of <code>AbstractArray</code> defined over a set of orbitals (see also <code>orbaxes</code>). It wraps a regular array that can be obtained with <code>parent(::OrbitalSliceArray)</code>, and supports all the general AbstractArray interface. In addition, it also supports indexing using <code>siteselector</code>s and <code>cellindices</code>. <code>OrbitalSliceVector</code> and <code>OrbitalSliceMatrix</code> are special cases of <code>OrbitalSliceArray</code> of dimension 1 and 2 respectively.</p><p>This is the common output type produced by <code>GreenFunctions</code> and most observables.</p><p>Note that for <code>m::OrbitalSliceMatrix</code>, <code>mat[i]</code> is equivalent to <code>mat[i,i]</code>, and <code>mat[; sel...]</code> is equivalent to <code>mat[(; sel...), (; sel...)]</code>.</p><p><strong><code>siteselector</code> indexing</strong></p><pre><code class="nohighlight hljs">mat[(; rowsites...), (; colsites...)]
mat[rowsel::SiteSelector, colsel::SiteSelector]</code></pre><p>If we index an <code>OrbitalSliceMatrix</code> with <code>s::NamedTuple</code> or a <code>siteselector(; s...)</code>, we obtain a new <code>OrbitalSliceMatrix</code> over the orbitals of the selected sites.</p><p><strong><code>sites</code> indexing</strong></p><pre><code class="nohighlight hljs">mat[sites(cell_index, site_indices)]
mat[sites(row_cell_index, row_site_indices), sites(col_cell_index, col_site_indices)]</code></pre><p>If we index an <code>OrbitalSliceMatrix</code> with <code>sites</code>, we obtain an unwrapped <code>Matrix</code> over the sites with <code>site_indices</code> within cell with <code>cell_index</code>. Here <code>site_indices</code> can be an <code>Int</code>, a container of <code>Int</code>, or a <code>:</code> (for all sites in the unit cell). If any of the specified sites are not already in <code>orbaxes(mat)</code>, indexing will throw an error.</p><p>Note that in this case we do not obtain a new <code>OrbitalSliceMatrix</code>. This behavior is required for performance, as re-wrapping in a new <code>OrbitalSliceMatrix</code> requires recomputing and allocating the new <code>orbaxes</code>.</p><pre><code class="nohighlight hljs">view(mat, rows::CellSites, cols::Cellsites = rows)</code></pre><p>Like the above, but returns a view instead of a copy of the indexed orbital matrix.</p><p>Note: <code>diagonal</code> indexing is currently not supported by <code>OrbitalSliceArray</code>.</p><p><strong><code>unflat</code> conversion</strong></p><pre><code class="nohighlight hljs">unflat(mat)</code></pre><p>Convert a <code>mat::OrbitalSliceMatrix</code> (or an <code>OrbitalSliceArray</code> in general) to an array of site blocks, where each block is a view into the original <code>mat</code>.</p><pre><code class="nohighlight hljs">unflat(SMatrix{N,N}, mat)</code></pre><p>Like the above but converting each block view into an NxN SMatrix, see <code>unflat</code> for details.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; g = LP.linear() |&gt; hamiltonian(hopping(SA[0 1; 1 0]) + onsite(I), orbitals = 2) |&gt; supercell(4) |&gt; greenfunction;

julia&gt; mat = g(0.2)[region = r -&gt; 2&lt;=r[1]&lt;=4]
6×6 OrbitalSliceMatrix{ComplexF64,Matrix{ComplexF64}}:
 -1.93554e-9-0.545545im          0.0-0.0im               0.0-0.0im              -0.5+0.218218im          0.4+0.37097im           0.0+0.0im
         0.0-0.0im       -1.93554e-9-0.545545im         -0.5+0.218218im          0.0-0.0im               0.0+0.0im               0.4+0.37097im
         0.0-0.0im              -0.5+0.218218im  -1.93554e-9-0.545545im          0.0-0.0im               0.0+0.0im              -0.5+0.218218im
        -0.5+0.218218im          0.0-0.0im               0.0-0.0im       -1.93554e-9-0.545545im         -0.5+0.218218im          0.0+0.0im
         0.4+0.37097im           0.0+0.0im               0.0+0.0im              -0.5+0.218218im  -1.93554e-9-0.545545im          0.0-0.0im
         0.0+0.0im               0.4+0.37097im          -0.5+0.218218im          0.0+0.0im               0.0-0.0im       -1.93554e-9-0.545545im

julia&gt; mat[(; cells = SA[1]), (; cells = SA[0])]
2×4 OrbitalSliceMatrix{ComplexF64,Matrix{ComplexF64}}:
 0.4+0.37097im  0.0+0.0im       0.0+0.0im       -0.5+0.218218im
 0.0+0.0im      0.4+0.37097im  -0.5+0.218218im   0.0+0.0im

julia&gt; mat[sites(SA[1], 1)]
2×2 Matrix{ComplexF64}:
 -1.93554e-9-0.545545im          0.0-0.0im
         0.0-0.0im       -1.93554e-9-0.545545im</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`siteselector`, `cellindices`, `orbaxes`, `unflat`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL2335-L2415">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.OrbitalSliceVector" href="#Quantica.OrbitalSliceVector"><code>Quantica.OrbitalSliceVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OrbitalSliceArray &lt;: AbstractArray</code></pre><p>A type of <code>AbstractArray</code> defined over a set of orbitals (see also <code>orbaxes</code>). It wraps a regular array that can be obtained with <code>parent(::OrbitalSliceArray)</code>, and supports all the general AbstractArray interface. In addition, it also supports indexing using <code>siteselector</code>s and <code>cellindices</code>. <code>OrbitalSliceVector</code> and <code>OrbitalSliceMatrix</code> are special cases of <code>OrbitalSliceArray</code> of dimension 1 and 2 respectively.</p><p>This is the common output type produced by <code>GreenFunctions</code> and most observables.</p><p>Note that for <code>m::OrbitalSliceMatrix</code>, <code>mat[i]</code> is equivalent to <code>mat[i,i]</code>, and <code>mat[; sel...]</code> is equivalent to <code>mat[(; sel...), (; sel...)]</code>.</p><p><strong><code>siteselector</code> indexing</strong></p><pre><code class="nohighlight hljs">mat[(; rowsites...), (; colsites...)]
mat[rowsel::SiteSelector, colsel::SiteSelector]</code></pre><p>If we index an <code>OrbitalSliceMatrix</code> with <code>s::NamedTuple</code> or a <code>siteselector(; s...)</code>, we obtain a new <code>OrbitalSliceMatrix</code> over the orbitals of the selected sites.</p><p><strong><code>sites</code> indexing</strong></p><pre><code class="nohighlight hljs">mat[sites(cell_index, site_indices)]
mat[sites(row_cell_index, row_site_indices), sites(col_cell_index, col_site_indices)]</code></pre><p>If we index an <code>OrbitalSliceMatrix</code> with <code>sites</code>, we obtain an unwrapped <code>Matrix</code> over the sites with <code>site_indices</code> within cell with <code>cell_index</code>. Here <code>site_indices</code> can be an <code>Int</code>, a container of <code>Int</code>, or a <code>:</code> (for all sites in the unit cell). If any of the specified sites are not already in <code>orbaxes(mat)</code>, indexing will throw an error.</p><p>Note that in this case we do not obtain a new <code>OrbitalSliceMatrix</code>. This behavior is required for performance, as re-wrapping in a new <code>OrbitalSliceMatrix</code> requires recomputing and allocating the new <code>orbaxes</code>.</p><pre><code class="nohighlight hljs">view(mat, rows::CellSites, cols::Cellsites = rows)</code></pre><p>Like the above, but returns a view instead of a copy of the indexed orbital matrix.</p><p>Note: <code>diagonal</code> indexing is currently not supported by <code>OrbitalSliceArray</code>.</p><p><strong><code>unflat</code> conversion</strong></p><pre><code class="nohighlight hljs">unflat(mat)</code></pre><p>Convert a <code>mat::OrbitalSliceMatrix</code> (or an <code>OrbitalSliceArray</code> in general) to an array of site blocks, where each block is a view into the original <code>mat</code>.</p><pre><code class="nohighlight hljs">unflat(SMatrix{N,N}, mat)</code></pre><p>Like the above but converting each block view into an NxN SMatrix, see <code>unflat</code> for details.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; g = LP.linear() |&gt; hamiltonian(hopping(SA[0 1; 1 0]) + onsite(I), orbitals = 2) |&gt; supercell(4) |&gt; greenfunction;

julia&gt; mat = g(0.2)[region = r -&gt; 2&lt;=r[1]&lt;=4]
6×6 OrbitalSliceMatrix{ComplexF64,Matrix{ComplexF64}}:
 -1.93554e-9-0.545545im          0.0-0.0im               0.0-0.0im              -0.5+0.218218im          0.4+0.37097im           0.0+0.0im
         0.0-0.0im       -1.93554e-9-0.545545im         -0.5+0.218218im          0.0-0.0im               0.0+0.0im               0.4+0.37097im
         0.0-0.0im              -0.5+0.218218im  -1.93554e-9-0.545545im          0.0-0.0im               0.0+0.0im              -0.5+0.218218im
        -0.5+0.218218im          0.0-0.0im               0.0-0.0im       -1.93554e-9-0.545545im         -0.5+0.218218im          0.0+0.0im
         0.4+0.37097im           0.0+0.0im               0.0+0.0im              -0.5+0.218218im  -1.93554e-9-0.545545im          0.0-0.0im
         0.0+0.0im               0.4+0.37097im          -0.5+0.218218im          0.0+0.0im               0.0-0.0im       -1.93554e-9-0.545545im

julia&gt; mat[(; cells = SA[1]), (; cells = SA[0])]
2×4 OrbitalSliceMatrix{ComplexF64,Matrix{ComplexF64}}:
 0.4+0.37097im  0.0+0.0im       0.0+0.0im       -0.5+0.218218im
 0.0+0.0im      0.4+0.37097im  -0.5+0.218218im   0.0+0.0im

julia&gt; mat[sites(SA[1], 1)]
2×2 Matrix{ComplexF64}:
 -1.93554e-9-0.545545im          0.0-0.0im
         0.0-0.0im       -1.93554e-9-0.545545im</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`siteselector`, `cellindices`, `orbaxes`, `unflat`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL2335-L2415">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.position" href="#Base.position"><code>Base.position</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">position(b::ExternalPresets.WannierBuilder)</code></pre><p>Returns the position operator in the Wannier basis. It is given as a <code>r::BarebonesOperator</code> object, which can be indexed as <code>r[s, s´]</code> to obtain matrix elements <code>⟨s|R|s´⟩</code> of the position operator <code>R</code> (a vector). Here <code>s</code> and <code>s´</code> represent site indices, constructed with <code>sites(cell, inds)</code>. To obtain the matrix between cells separated by <code>dn::SVector{L,Int}</code>, do <code>r[dn]</code>. The latter will throw an error if the <code>dn</code> harmonic is not present.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`current`, `sites`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL267-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reverse" href="#Base.reverse"><code>Base.reverse</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reverse(lat_or_h::Union{Lattice,AbstractHamiltonian})</code></pre><p>Build a new lattice or hamiltonian with the orientation of all Bravais vectors and harmonics reversed.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`reverse!`, `transform`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL342-L350">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reverse!" href="#Base.reverse!"><code>Base.reverse!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reverse!(lat_or_h::Union{Lattice,AbstractHamiltonian})</code></pre><p>In-place version of <code>reverse</code>, inverts all Bravais vectors and harmonics of <code>lat_or_h</code>.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`reverse`, `transform`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL353-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.ishermitian" href="#LinearAlgebra.ishermitian"><code>LinearAlgebra.ishermitian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ishermitian(h::Hamiltonian)</code></pre><p>Check whether <code>h</code> is Hermitian. This is not supported for <code>h::ParametricHamiltonian</code>, as the result can depend of the specific values of its parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL731-L737">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.ExternalPresets.wannier90" href="#Quantica.ExternalPresets.wannier90"><code>Quantica.ExternalPresets.wannier90</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ExternalPresets.wannier90(filename::String; kw...)</code></pre><p>Import a Wannier90 tight-binding file in the form of a <code>w::EP.WannierBuilder</code> object. It can be used to obtain a <code>Hamiltonian</code> with <code>hamiltonian(w)</code>, and the matrix of the position operator with <code>sites(w)</code>.</p><pre><code class="nohighlight hljs">ExternalPresets.wannier90(filename, model::AbstractModel; kw...)</code></pre><p>Modify the <code>WannierBuilder</code> after import by adding <code>model</code> to it.</p><pre><code class="nohighlight hljs">push!(w::EP.WannierBuilder, modifier::AbstractModifier)
w |&gt; modifier</code></pre><p>Applies a <code>modifier</code> to <code>w</code>.</p><p><strong>Keywords</strong></p><ul><li>htol: skip matrix elements of the Hamiltonian smaller than this (in absolute value). Default: <code>1e-8</code></li><li>rtol: skip non-diagonal matrix elements of the position operator smaller than this (in absolute value). Default: <code>1e-8</code></li><li>dim: dimensionality of the embedding space for the Wannier orbitals, dropping trailing dimensions beyond <code>dim</code> if smaller than 3. Default: <code>3</code></li><li>latdim: dimensionality of the lattice, dropping trailing dimensions beyond <code>latdim</code> if smaller than 3. Should be <code>latdim &lt;= dim</code>. Default: <code>dim</code></li><li>type: override the real number type of the imported system. Default: <code>Float64</code></li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; w = EP.wannier90(&quot;wannier_tb.dat&quot;, @onsite((; o) -&gt; o);  htol = 1e-4, rtol = 1e-4, dim = 2, type = Float32)
WannierBuilder{Float32,2,2} : 2-dimensional Hamiltonian builder from Wannier90 input, with positions of type Float32 in 2D-dimensional space
  cells      : 151
  elements   : 6724
  modifiers  : 1

julia&gt; h = hamiltonian(w)
ParametricHamiltonian{Float32,2,2}: Parametric Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 151
  Harmonic size    : 10 × 10
  Orbitals         : [1]
  Element type     : scalar (ComplexF32)
  Onsites          : 10
  Hoppings         : 6704
  Coordination     : 670.4
  Parameters       : [:o]

julia&gt; r = position(w)
BarebonesOperator{2}: a simple collection of 2D Bloch harmonics
  Bloch harmonics  : 151
  Harmonic size    : 10 × 10
  Element type     : SVector{2, ComplexF32}
  Nonzero elements : 7408

julia&gt; r[sites(SA[0,0], 3), sites(SA[1,0],2)]
2-element SVector{2, ComplexF32} with indices SOneTo(2):
 -0.0016230071f0 - 0.00012927242f0im
   0.008038711f0 + 0.004102786f0im</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`hamiltonian`, `position`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/presets/docstrings.jl#LL1-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.attach" href="#Quantica.attach"><code>Quantica.attach</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">attach(h::AbstractHamiltonian, args..; sites...)
attach(h::OpenHamiltonian, args...; sites...)</code></pre><p>Build an <code>h´::OpenHamiltonian</code> by attaching (adding) a <code>Σ::SelfEnergy</code> to a finite number of sites in <code>h</code> specified by <code>siteselector(; sites...)</code>. This also defines a &quot;contact&quot; on said sites that can be referred to (with index <code>i::Integer</code> for the i-th attached contact) when slicing Green functions later. Self-energies are taken into account when building the Green function <code>g(ω) = (ω - h´ - Σ(ω))⁻¹</code> of the resulting <code>h´</code>, see <code>greenfunction</code>.</p><p><strong>Self-energy forms</strong></p><p>The different forms of <code>args</code> yield different types of self-energies <code>Σ</code>. Currently supported forms are:</p><pre><code class="nohighlight hljs">attach(h, gs::GreenSlice, coupling::AbstractModel; transform = missing, sites...)</code></pre><p>Adds a generic self-energy <code>Σ(ω) = V´⋅gs(ω)⋅V</code> on <code>h</code>&#39;s <code>sites</code>, where <code>V</code> and <code>V´</code> are couplings (given by <code>coupling</code>) between said <code>sites</code> and the <code>LatticeSlice</code> in <code>gs</code> (after applying <code>transform</code> to the latter). Allowed forms of <code>gs</code> include both <code>g[bath_sites...]</code> and <code>g[contactind::Integer]</code> where <code>g</code> is any <code>GreenFunction</code>.</p><pre><code class="nohighlight hljs">attach(h, model::ParametricModel; sites...)</code></pre><p>Add self-energy <code>Σᵢⱼ(ω)</code> defined by a <code>model</code> composed of parametric terms (<code>@onsite</code> and <code>@hopping</code>) with <code>ω</code> as first argument, as in e.g. <code>@onsite((ω, r) -&gt; Σᵢᵢ(ω, r))</code> and <code>@hopping((ω, r, dr) -&gt; Σᵢⱼ(ω, r, dr))</code></p><pre><code class="nohighlight hljs">attach(h, nothing; sites...)</code></pre><p>Add a <code>nothing</code> contact with a null self-energy <code>Σᵢⱼ(ω) = 0</code> on selected sites, which in effect simply amounts to labeling those sites with a contact number, but does not lead to any dressing the Green function. This is useful for some <code>GreenFunction</code> solvers such as <code>GS.KPM</code> (see <code>greenfunction</code>), which need to know the sites of interest beforehand (the contact sites in this case).</p><pre><code class="nohighlight hljs">attach(h, g1D::GreenFunction; reverse = false, transform = identity, sites...)</code></pre><p>Add a self-energy <code>Σ(ω) = h₋₁⋅g1D(ω)[surface]⋅h₁</code> corresponding to a semi-infinite 1D lead (i.e. with a finite <code>boundary</code>, see <code>greenfunction</code>), where <code>h₁</code> and <code>h₋₁</code> are intercell couplings, and <code>g1D</code> is the lead <code>GreenFunction</code>. The <code>g1D(ω)</code> is taken at the <code>suface</code> unitcell, either adjacent to the <code>boundary</code> on its positive side (if <code>reverse = false</code>) or on its negative side (if <code>reverse = true</code>). Note that <code>reverse</code> only flips the direction we extend the lattice to form the lead, but does not flip the unit cell (may use <code>transform</code> for that) or any contacts in the lead. The positions of the selected <code>sites</code> in <code>h</code> must match, modulo an arbitrary displacement, those of the left or right unit cell surface of the lead (i.e. sites coupled to the adjacent unit cells), after applying <code>transform</code> to the latter. If they don&#39;t match, use the <code>attach</code> syntax below.</p><p>Advanced: If the <code>g1D</code> does not have any self-energies, the produced self-energy is in fact an <code>ExtendedSelfEnergy</code>, which is numerically more stable than a naive implementation of <code>RegularSelfEnergy</code>&#39;s, since <code>g1D(ω)[surface]</code> is never actually computed. Conversely, if <code>g1D</code> has self-energies attached, a <code>RegularSelfEnergy</code> is produced.</p><pre><code class="nohighlight hljs">attach(h, g1D::GreenFunction, coupling::AbstractModel; reverse = false, transform = identity,  sites...)</code></pre><p>Add a self-energy <code>Σ(ω) = V´⋅g1D(ω)[surface]⋅V</code> corresponding to a 1D lead (semi-infinite or infinite), but with couplings <code>V</code> and <code>V´</code>, defined by <code>coupling</code>, between <code>sites</code> and the <code>surface</code> lead unitcell (or the one with index zero if there is no boundary). See also Advanced note above. Note that if <code>coupling</code> is absent, it defaults to the intercell hopping in the <code>g1D</code> lead, as described above.</p><p><strong>Currying</strong></p><pre><code class="nohighlight hljs">h |&gt; attach(args...; sites...)</code></pre><p>Curried form equivalent to <code>attach(h, args...; sites...)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # A graphene flake with two out-of-plane cubic-lattice leads

julia&gt; g1D = LP.cubic(names = :C) |&gt; hamiltonian(hopping(1)) |&gt; supercell((0,0,1), region = RP.square(4)) |&gt; greenfunction(GS.Schur(boundary = 0));

julia&gt; coupling = hopping(1, range = 2);

julia&gt; gdisk = HP.graphene(a0 = 1, dim = 3) |&gt; supercell(region = RP.circle(10)) |&gt; attach(g1D, coupling; region = RP.square(4)) |&gt; attach(g1D, coupling; region = RP.square(4), reverse = true) |&gt; greenfunction;</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`greenfunction`, `GreenSolvers`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL1543-L1626">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.bands" href="#Quantica.bands"><code>Quantica.bands</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bands(h::AbstractHamiltonian, xcolᵢ...; kw...)</code></pre><p>Construct a <code>Bandstructure</code> object, which contains in particular a collection of continuously connected <code>Subband</code>s of <code>h</code>, obtained by diagonalizing the matrix <code>h(ϕs; params...)</code> on an <code>M</code>-dimensional mesh of points <code>(x₁, x₂, ..., xₘ)</code>, where each <code>xᵢ</code> takes values in the collection <code>xcolᵢ</code>. The mapping between points in the mesh points and values of <code>(ϕs; params...)</code> is defined by keyword <code>mapping</code> (<code>identity</code> by default, see Keywords). Diagonalization is multithreaded and will use all available Julia threads (start session with <code>julia -t N</code> to have <code>N</code> threads).</p><pre><code class="nohighlight hljs">bands(f::Function, xcolᵢ...; kw...)</code></pre><p>Like the above using <code>f(ϕs)::AbstractMatrix</code> in place of <code>h(ϕs; params...)</code>, and returning a <code>Vector{&lt;:Subband}</code> instead of a <code>Bandstructure</code> object. This is provided as a lower level driver without the added slicing functionality of a full <code>Bandstructure</code> object, see below.</p><pre><code class="nohighlight hljs">bands(h::AbstractHamiltonian; kw...)</code></pre><p>Equivalent to <code>bands(h::AbstractHamiltonian, xcolᵢ...; kw...)</code> with a default <code>xcolᵢ = subdiv(-π, π, 49)</code>.</p><p><strong>Keywords</strong></p><ul><li><code>solver</code>: eigensolver to use for each diagonalization (see <code>Eigensolvers</code>). Default: <code>ES.LinearAlgebra()</code></li><li><code>mapping</code>: a function of the form <code>(x, y, ...) -&gt; ϕs</code> or <code>(x, y, ...) -&gt; ftuple(ϕs...; params...)</code> that translates points <code>(x, y, ...)</code> in the mesh to Bloch phases <code>ϕs</code> or phase+parameter FrankenTuples <code>ftuple(ϕs...; params...)</code>. See also linecuts below. Default: <code>identity</code></li><li><code>transform</code>: function to apply to each eigenvalue after diagonalization. Default: <code>identity</code></li><li><code>degtol::Real</code>: maximum distance between to nearby eigenvalue so that they are classified as degenerate. Default: <code>sqrt(eps)</code></li><li><code>split::Bool</code>: whether to split bands into disconnected subbands. Default: <code>true</code></li><li><code>projectors::Bool</code>: whether to compute interpolating subspaces in each simplex (for use as GreenSolver). Default: <code>true</code></li><li><code>warn::Bool</code>: whether to emit warning when band dislocations are encountered. Default: <code>true</code></li><li><code>showprogress::Bool</code>: whether to show or not a progress bar. Default: <code>true</code></li><li><code>defects</code>: (experimental) a collection of extra points to add to the mesh, typically the location of topological band defects such as Dirac points, so that interpolation avoids creating dislocation defects in the bands. You need to also increase <code>patches</code> to repair the subband dislocations using the added defect vertices. Default: <code>()</code></li><li><code>patches::Integer</code>: (experimental) if a dislocation is encountered, attempt to patch it by searching for the defect recursively to a given order, or using the provided <code>defects</code> (preferred). Default: <code>0</code></li></ul><p><strong>Currying</strong></p><pre><code class="nohighlight hljs">h |&gt; bands(xcolᵢ...; kw...)</code></pre><p>Curried form of <code>bands</code> equivalent to <code>bands(h, xcolᵢ...; kw...)</code></p><p><strong>Band linecuts</strong></p><p>To do a linecut of a bandstructure along a polygonal path in the <code>L</code>-dimensional Brillouin zone, mapping a set of 1D points <code>xs</code> to a set of <code>nodes</code>, with <code>pts</code> interpolation points in each segment, one can use the following convenient syntax</p><pre><code class="nohighlight hljs">bands(h, subdiv(xs, pts); mapping = (xs =&gt; nodes))</code></pre><p>Here <code>nodes</code> can be a collection of <code>SVector{L}</code> or of named Brillouin zone points from the list (<code>:Γ</code>,<code>:K</code>, <code>:K´</code>, <code>:M</code>, <code>:X</code>, <code>:Y</code>, <code>:Z</code>). If <code>mapping = nodes</code>, then <code>xs</code> defaults to <code>0:length(nodes)-1</code>. See also <code>subdiv</code> for its alternative methods.</p><p><strong>Indexing and slicing</strong></p><pre><code class="nohighlight hljs">b[i]</code></pre><p>Extract <code>i</code>-th subband from <code>b::Bandstructure</code>. <code>i</code> can also be a <code>Vector</code>, an <code>AbstractRange</code> or any other argument accepted by <code>getindex(subbands::Vector, i)</code></p><pre><code class="nohighlight hljs">b[slice::Tuple]</code></pre><p>Compute a section of <code>b::Bandstructure</code> with a &quot;plane&quot; defined by <code>slice = (ϕ₁, ϕ₂,..., ϕₗ[, ϵ])</code>, where each <code>ϕᵢ</code> or <code>ϵ</code> can be a real number (representing a fixed momentum or energy) or a <code>:</code> (unconstrained along that dimension). For bands of an <code>L</code>-dimensional lattice, <code>slice</code> will be padded to an <code>L+1</code>-long tuple with <code>:</code> if necessary. The result is a collection of of sliced <code>Subband</code>s.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; phis = range(0, 2pi, length = 50); h = LP.honeycomb() |&gt; hamiltonian(@hopping((; t = 1) -&gt; t));

julia&gt; bands(h(t = 1), phis, phis)
Bandstructure{Float64,3,2}: 3D Bandstructure over a 2-dimensional parameter space of type Float64
  Subbands  : 1
  Vertices  : 5000
  Edges     : 14602
  Simplices : 9588

julia&gt; bands(h, phis, phis; mapping = (x, y) -&gt; ftuple(0, x; t = y/2π))
Bandstructure{Float64,3,2}: 3D Bandstructure over a 2-dimensional parameter space of type Float64
  Subbands  : 1
  Vertices  : 4950
  Edges     : 14553
  Simplices : 9604

julia&gt; bands(h(t = 1), subdiv((0, 2, 3), (20, 30)); mapping = (0, 2, 3) =&gt; (:Γ, :M, :K))
Bandstructure{Float64,2,1}: 2D Bandstructure over a 1-dimensional parameter space of type Float64
  Subbands  : 1
  Vertices  : 97
  Edges     : 96
  Simplices : 96</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`spectrum`, `subdiv`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL1427-L1524">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.bravais_matrix" href="#Quantica.bravais_matrix"><code>Quantica.bravais_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bravais_matrix(lat::Lattice)
bravais_matrix(h::AbstractHamiltonian)</code></pre><p>Return the Bravais matrix of lattice <code>lat</code> or AbstractHamiltonian <code>h</code>, with Bravais vectors as its columns.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; lat = lattice(sublat((0,0)), bravais = ((1.0, 2), (3, 4)));

julia&gt; bravais_matrix(lat)
2×2 SMatrix{2, 2, Float64, 4} with indices SOneTo(2)×SOneTo(2):
 1.0  3.0
 2.0  4.0
</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`lattice`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL139-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.combine" href="#Quantica.combine"><code>Quantica.combine</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">combine(lats::Lattice...)</code></pre><p>If all <code>lats</code> have compatible Bravais vectors, combine them into a single lattice. If necessary, sublattice names are renamed to remain unique.</p><pre><code class="nohighlight hljs">combine(hams::Hamiltonians...; coupling = TighbindingModel())</code></pre><p>Combine a collection <code>hams</code> of Hamiltonians into one by combining their corresponding lattices, and optionally by adding a coupling between them, given by the hopping terms in <code>coupling</code>.</p><p>Note that the <code>coupling</code> model will be applied to the combined lattice (which may have renamed sublattices to avoid name collissions). However, only hopping terms between different <code>hams</code> blocks will be applied.</p><p><strong>Limitations</strong></p><p>Currently, <code>combine</code> only works with <code>Lattice{T}</code> <code>AbstractHamiltonians{T}</code> with the same <code>T</code>. Furthermore, if any of the <code>hams</code> is a <code>ParametricHamiltonian</code> or <code>coupling</code> is a <code>ParametricModel</code>, the sublattice names of all <code>hams</code> must be distinct. This ensures that parametric models, which get applied through <code>Modifiers</code> after construction of the <code>ParametricHamiltonian</code>, are not applied to the wrong sublattice, since sublattice names could be renamed by <code>combine</code> if they are not unique. Therefore, be sure to choose unique sublattice names upon construction for all the <code>hams</code> to be combined (see <code>lattice</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # Building Bernal-stacked bilayer graphene

julia&gt; hbot = HP.graphene(a0 = 1, dim = 3, names = (:A,:B));

julia&gt; htop = translate(HP.graphene(a0 = 1, dim = 3, names = (:C,:D)), (0, 1/√3, 1/√3));

julia&gt; h2 = combine(hbot, htop; coupling = hopping(1, sublats = :B =&gt; :C) |&gt; plusadjoint)
Hamiltonian{Float64,3,2}: Hamiltonian on a 2D Lattice in 3D space
  Bloch harmonics  : 5
  Harmonic size    : 4 × 4
  Orbitals         : [1, 1, 1, 1]
  Element type     : scalar (ComplexF64)
  Onsites          : 0
  Hoppings         : 14
  Coordination     : 3.5</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`hopping`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL425-L472">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.conductance" href="#Quantica.conductance"><code>Quantica.conductance</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conductance(gs::GreenSlice; nambu = false)</code></pre><p>Given a slice <code>gs = g[i::Integer, j::Integer]</code> of a <code>g::GreenFunction</code>, build a partially evaluated object <code>G::Conductance</code> representing the zero-temperature, linear, differential conductance <code>Gᵢⱼ = dIᵢ/dVⱼ</code> between contacts <code>i</code> and <code>j</code> at arbitrary bias <code>ω = eV</code> in units of <code>e^2/h</code>. <code>Gᵢⱼ</code> is given by</p><pre><code class="nohighlight hljs">  Gᵢⱼ =  e^2/h × Tr{[im*δᵢⱼ(gʳ-gᵃ)Γⁱ-gʳΓⁱgᵃΓʲ]}         (nambu = false)
  Gᵢⱼ =  e^2/h × Tr{[im*δᵢⱼ(gʳ-gᵃ)Γⁱτₑ-gʳΓⁱτ₃gᵃΓʲτₑ]}   (nambu = true)</code></pre><p>Here <code>gʳ = g(ω)</code> and <code>gᵃ = (gʳ)&#39; = g(ω&#39;)</code> are the retarded and advanced Green function of the system, and <code>Γⁱ = im * (Σⁱ - Σⁱ&#39;)</code> is the decay rate at contact <code>i</code>. For Nambu systems (<code>nambu = true</code>), the matrices <code>τₑ=[I 0; 0 0]</code> and <code>τ₃ = [I 0; 0 -I]</code> ensure that charge reversal in Andreev reflections is properly taken into account. For normal systems (<code>nambu = false</code>), the total current at finite bias and temperatures is given by <span>$Iᵢ = e/h × ∫ dω ∑ⱼ [fᵢ(ω) - fⱼ(ω)] Gᵢⱼ(ω)$</span>, where <span>$fᵢ(ω)$</span> is the Fermi distribution in lead <code>i</code>.</p><p><strong>Keywords</strong></p><ul><li><code>nambu</code> : whether to consider the Hamiltonian of the system is written in a Nambu basis, each site containing <code>N</code> electron orbitals followed by <code>N</code> hole orbitals.</li></ul><p><strong>Full evaluation</strong></p><pre><code class="nohighlight hljs">G(ω; params...)</code></pre><p>Compute the conductance at the specified contacts.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # A central system g0 with two 1D leads and transparent contacts

julia&gt; glead = LP.square() |&gt; hamiltonian(hopping(1)) |&gt; supercell((1,0), region = r-&gt;-2&lt;r[2]&lt;2) |&gt; greenfunction(GS.Schur(boundary = 0));

julia&gt; g0 = LP.square() |&gt; hamiltonian(hopping(1)) |&gt; supercell(region = r-&gt;-2&lt;r[2]&lt;2 &amp;&amp; r[1]≈0) |&gt; attach(glead, reverse = true) |&gt; attach(glead) |&gt; greenfunction;

julia&gt; G = conductance(g0[1])
Conductance{Float64}: Zero-temperature conductance dIᵢ/dVⱼ from contacts i,j, in units of e^2/h
  Current contact  : 1
  Bias contact     : 1

julia&gt; G(0.2) ≈ 3
true</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`greenfunction`, `ldos`, `current`, `josephson`, `transmission`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL2020-L2068">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.current" href="#Quantica.current"><code>Quantica.current</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">current(h::AbstractHamiltonian; charge = -I, direction = 1)</code></pre><p>Build an <code>Operator</code> object that behaves like a <code>ParametricHamiltonian</code> in regards to calls and getindex, but whose matrix elements are hoppings <span>$im*(rⱼ-rᵢ)[direction]*charge*tⱼᵢ$</span>, where <code>tᵢⱼ</code> are the hoppings in <code>h</code>. This operator is equal to <span>$∂h/∂Aᵢ$</span>, where <code>Aᵢ</code> is a gauge field along <code>direction = i</code>.</p><pre><code class="nohighlight hljs">current(gs::GreenSlice; charge = -I, direction = missing)</code></pre><p>Build <code>Js::CurrentDensitySlice</code>, a partially evaluated object representing the equilibrium local current density <code>Jᵢⱼ(ω)</code> at arbitrary energy <code>ω</code> from site <code>j</code> to site <code>i</code>, both taken from a specific lattice slice. The current is computed along a given <code>direction</code> (see Keywords).</p><pre><code class="nohighlight hljs">current(gω::GreenSolution; charge = -I, direction = missing)</code></pre><p>Build <code>Jω::CurrentDensitySolution</code>, as above, but for <code>Jᵢⱼ(ω)</code> at a fixed <code>ω</code> and arbitrary sites <code>i, j</code>. See also <code>greenfunction</code> for details on building a <code>GreenSlice</code> and <code>GreenSolution</code>.</p><p>The local current density is defined here as <span>$Jᵢⱼ(ω) = (2/h) rᵢⱼ Re Tr[(Hᵢⱼgⱼᵢ(ω) - gᵢⱼ(ω)Hⱼᵢ) * charge]$</span>, with the integrated local current given by <span>$Jᵢⱼ = ∫ f(ω) Jᵢⱼ(ω) dω$</span>. Here <code>Hᵢⱼ</code> is the hopping from site <code>j</code> at <code>rⱼ</code> to <code>i</code> at <code>rᵢ</code>, <code>rᵢⱼ = rᵢ - rⱼ</code>, <code>charge</code> is the charge of carriers in orbital space (see Keywords), and <code>gᵢⱼ(ω)</code> is the retarded Green function between said sites.</p><p><strong>Keywords</strong></p><ul><li><code>charge</code> : for multiorbital sites, <code>charge</code> can be a general matrix, which allows to compute arbitrary currents, such as spin currents.</li><li><code>direction</code>: as defined above, <code>Jᵢⱼ(ω)</code> is a vector. If <code>direction</code> is <code>missing</code> the norm <code>|Jᵢⱼ(ω)|</code> is returned. If it is an <code>u::Union{SVector,Tuple}</code>, <code>u⋅Jᵢⱼ(ω)</code> is returned. If an <code>n::Integer</code>, <code>Jᵢⱼ(ω)[n]</code> is returned.</li></ul><p><strong>Full evaluation</strong></p><pre><code class="nohighlight hljs">Jω[sites...]
Js(ω; params...)</code></pre><p>Given a partially evaluated <code>Jω::CurrentDensitySolution</code> or <code>ρs::CurrentDensitySlice</code>, build a sparse matrix <code>Jᵢⱼ(ω)</code> along the specified <code>direction</code> of fully evaluated local current densities.</p><p>Note: Evaluating the current density returns a <code>SparseMatrixCSC</code> currently, instead of a <code>OrbitalSliceMatrix</code>, since the latter is designed for dense arrays.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; # A semi-infinite 1D lead with a magnetic field `B`

julia&gt; g = LP.square() |&gt; supercell((1,0), region = r-&gt;-2&lt;r[2]&lt;2) |&gt; hamiltonian(@hopping((r, dr; B = 0.1) -&gt; cis(B * dr&#39; * SA[r[2],-r[1]]))) |&gt; greenfunction(GS.Schur(boundary = 0));

julia&gt; J = current(g[cells = SA[1]])
CurrentDensitySlice{Float64} : current density at a fixed location and arbitrary energy
  charge      : LinearAlgebra.UniformScaling{Int64}(-1)
  direction   : missing

julia&gt; J(0.2; B = 0.1)
3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:
  ⋅         0.0290138   ⋅
 0.0290138   ⋅         0.0290138
  ⋅         0.0290138   ⋅

julia&gt; J(0.2; B = 0.0)
3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:
  ⋅           7.77156e-16   ⋅
 7.77156e-16   ⋅           5.55112e-16
  ⋅           5.55112e-16   ⋅</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`greenfunction`, `ldos`, `conductance`, `josephson`, `densitymatrix`, `transmission`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL1945-L2017">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.decay_lengths" href="#Quantica.decay_lengths"><code>Quantica.decay_lengths</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Quantica.decay_lengths(g::GreenFunctionSchurLead1D, µ = 0; reverse = false)
Quantica.decay_lengths(h::AbstractHamiltonian1D, µ = 0; reverse = false)</code></pre><p>Compute the decay lengths of evanescent modes of a 1D <code>AbstractHamiltonian</code> <code>h</code> or a 1D <code>GreenFunction</code> <code>g</code> using the <code>GS.Schur</code> solver. The modes decaying towards positive direction (relative to the Bravais vector) are used, unless <code>reverse = true</code>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; h = LP.linear() |&gt; supercell(4) |&gt; hopping(1) - @onsite((r; U = 2) -&gt; ifelse(iseven(r[1]), U, -U));

julia&gt; Quantica.decay_lengths(h(U=2))
1-element Vector{Float64}:
 0.28364816427662776</code></pre><p><strong>See also:</strong></p><pre><code class="nohighlight hljs">`Quantica.gaps`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL2718-L2739">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.densitymatrix" href="#Quantica.densitymatrix"><code>Quantica.densitymatrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">densitymatrix(gs::GreenSlice; opts...)</code></pre><p>Compute a <code>ρ::DensityMatrix</code> at thermal equilibrium on sites encoded in <code>gs</code>. The actual matrix for given system parameters <code>params</code>, and for a given chemical potential <code>mu</code> and temperature <code>kBT</code> is obtained by calling <code>ρ(mu = 0, kBT = 0; params...)</code>. The algorithm used is specialized for the GreenSolver used, if available. In this case, <code>opts</code> are options for said algorithm.</p><pre><code class="nohighlight hljs">densitymatrix(gs::GreenSlice, path::AbstractIntegrationPath; opts..., quadgk_opts...)</code></pre><p>As above, but using a generic algorithm that relies on numerical integration of the Green function <code>gs(ω)</code> along a contour in the complex-ω plane, defined by the <code>path</code> object. See <code>Paths</code> for available paths. Most integration paths employ the Cauchy theorem, and therefore assume that <code>gs(ω)</code> is fully analytic between the path and the real axis. This may not be true if <code>gs</code> contains user-defined contacts created using <code>attach(model)</code> with general ω-dependent models, but note that Quantica will not check for analyticity. Keywords <code>quadgk_opts</code> are passed to the <code>QuadGK.quadgk</code> integration routine.</p><pre><code class="nohighlight hljs">densitymatrix(gs::GreenSlice, ωscale::Real; kw...)</code></pre><p>As above with <code>path = Paths.radial(ωscale, π/4)</code>, which computes the density matrix by integrating the Green function from <code>ω = -Inf</code> to <code>ω = Inf</code> along a <code>ϕ = π/4</code> radial complex path, see <code>Paths</code> for details. Here <code>ωscale</code> should correspond to some typical energy scale in the system, which dictates the speed at which we integrate the radial paths (the integration runtime may depend on <code>ωscale</code>, but not the result).</p><pre><code class="nohighlight hljs">densitymatrix(gs::GreenSlice, ωs::NTuple{N,Real}; kw...)</code></pre><p>As above, but with a <code>path = Paths.sawtooth(ωs)</code>, which uses a sawtooth-shaped path touching points <code>ωs</code> on the real axes. Ideally, these values should span the full system bandwidth.</p><p><strong>Full evaluation</strong></p><pre><code class="nohighlight hljs">ρ(μ = 0, kBT = 0; params...)   # where ρ::DensityMatrix</code></pre><p>Evaluate the density matrix at chemical potential <code>μ</code> and temperature <code>kBT</code> (in the same units as the Hamiltonian) for the given <code>g</code> parameters <code>params</code>, if any. The result is given as an <code>OrbitalSliceMatrix</code>, see its docstring for further details.</p><p><strong>Algorithms and keywords</strong></p><p>The generic integration algorithm allows for the following <code>opts</code> (see also <code>josephson</code>):</p><ul><li><code>omegamap</code>: a function <code>ω -&gt; (; params...)</code> that translates <code>ω</code> at each point in the integration contour to a set of system parameters. Useful for <code>ParametricHamiltonians</code> which include terms <code>Σ(ω)</code> that depend on a parameter <code>ω</code> (one would then use <code>omegamap = ω -&gt; (; ω)</code>). Default: <code>ω -&gt; (;)</code>, i.e. no mapped parameters.</li><li><code>callback</code>: a function to be called as <code>callback(xs..., y)</code> at each point in the integration, where <code>xs</code> is the integration point (e.g. <code>xs = (ω,)</code> along a contour) and <code>y</code> is the integrand evaluated at that point. Useful for inspection and debugging, e.g. <code>callback(x, y) = @show x</code>. Default: <code>Returns(nothing)</code>.</li><li><code>atol</code>: absolute integration tolerance. The default <code>1e-7</code> is chosen to avoid excessive integration times when the current is actually zero. Default <code>1e-7</code>.</li></ul><p>The <code>quadgk_opts</code> are extra keyword arguments (other than <code>atol</code>) to pass on to the function <code>QuadGK.quadgk</code> that is used for integrations.</p><p>Currently, the following GreenSolvers implement dedicated densitymatrix algorithms:</p><ul><li><code>GS.Schur</code>: based on numerical integration over Bloch phase (1D and 2D). Boundaries and non-empty contacts are not currently supported. Assumes a Hermitian AbstractHamiltonian. <code>opts</code> can contain a <code>callback</code>.</li><li><code>GS.Spectrum</code>: based on summation occupation-weigthed eigenvectors. No <code>opts</code>.</li><li><code>GS.KPM</code>: based on the Chebyshev expansion of the Fermi function. Currently only works for zero temperature and only supports <code>nothing</code> contacts (see <code>attach</code>). No <code>opts</code>.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; g = HP.graphene(a0 = 1) |&gt; supercell(region = RP.circle(10)) |&gt; greenfunction(GS.Spectrum());

julia&gt; ρ = densitymatrix(g[region = RP.circle(0.5)])
DensityMatrix: density matrix on specified sites with solver of type DensityMatrixSpectrumSolver

julia&gt; ρ()  # with mu = kBT = 0 by default
2×2 OrbitalSliceMatrix{ComplexF64,Matrix{ComplexF64}}:
       0.5+0.0im  -0.262865+0.0im
 -0.262865+0.0im        0.5+0.0im</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`greenfunction`, `josephson`, `ldos`, `current`, `conductance`, `transmission`, `OrbitalSliceArray`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL2113-L2185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.deserialize" href="#Quantica.deserialize"><code>Quantica.deserialize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deserialize(as::AppliedSerializer, v; params...)</code></pre><p>Construct <code>h(; params...)</code>, where <code>h = Quantica.parametric_hamiltonian(as)</code> is the <code>AbstractHamiltonian</code> enclosed in <code>as</code>, with the matrix elements enconded in <code>v = serialize(s)</code> restored (i.e. overwritten). See <code>serialize</code> for details.</p><pre><code class="nohighlight hljs">deserialize(m::OrbitalSliceArray, v)</code></pre><p>Reconstruct an <code>OrbitalSliceArray</code> with the same structure as <code>m</code> but with the matrix elements enconded in <code>v</code>. This <code>v</code> is typically the result of a <code>serialize</code> call to a another similar <code>m</code>, but the only requirement is that is has the correct size. If <code>v</code> has the wrong eltype, it will be reintepreted to match the eltype of <code>m</code>.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`serializer`, `serialize`, `serialize!`, `deserialize!`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL2619-L2635">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.deserialize!" href="#Quantica.deserialize!"><code>Quantica.deserialize!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deserialize!(as::AppliedSerializer, v; params...)</code></pre><p>In-place version of <code>deserialize</code>. It returns <code>h´ = Quantica.call!(h; params...)</code> with serialised elements <code>v</code> restored (i.e. overwritten). Here <code>h = Quantica.parent_hamiltonian(s)</code> is the <code>AbstractHamiltonian</code> used to construct <code>as</code>. The resulting <code>h´::Hamiltonian</code> is not an independent copy, but is aliased with <code>h</code>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; h = HP.graphene() |&gt; supercell(2);

julia&gt; s = serializer(h)
AppliedSerializer : translator between a selection of of matrix elements of an AbstractHamiltonian and a collection of scalars
  Object            : Hamiltonian
  Object parameters : none
  Stream parameter  : :stream
  Output eltype     : ComplexF64
  Encoder/Decoder   : Single
  Length            : 24

julia&gt; h === deserialize!(s, serialize(s))
true

julia&gt; h === deserialize(s, serialize(s))
false

julia&gt; h == deserialize(s, serialize(s))
true</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`serializer`, `serialize`, `serialize!`, `deserialize`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL2638-L2673">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.diagonal" href="#Quantica.diagonal"><code>Quantica.diagonal</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diagonal(i; kernel = missing)</code></pre><p>Wrapper over site or orbital indices <code>i</code> (used to index into a <code>g::GreenFunction</code> or <code>g::GreenSolution</code>) that represent purely diagonal entries. Here <code>i</code> can be any index accepted in <code>g[i,i]</code>, e.g. <code>i::Integer</code> (contact index), <code>i::Colon</code> (merged contacts), <code>i::SiteSelector</code> (selected sites), etc.</p><p>If <code>kernel = Q</code> (a matrix) instead of <code>missing</code>, each diagonal block for multiorbital site <code>i</code> is replaced with <code>Tr(gᵢᵢQ)</code>.</p><p>For a <code>gω::GreenSolution</code>, <code>gω[diagonal(sel)] = diag(gω[sel, sel])</code>, although where possible the former computation is done more efficiently internally.</p><pre><code class="nohighlight hljs">diagonal(; kernel = missing, sites...)</code></pre><p>Equivalent to <code>diagonal(siteselector(; sites...); kernel)</code></p><p><strong>Keywords</strong></p><ul><li><code>kernel</code>: if missing, all orbitals in the diagonal <code>g[i, i]</code> are returned when indexing <code>g[diagonal(i)]</code>. Otherwise, <code>Tr(g[site, site]*kernel)</code> for each site included in <code>i</code> is returned.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; g = HP.graphene(orbitals = 2) |&gt; attach(nothing, cells = (0,0)) |&gt; greenfunction();

julia&gt; g(1)[diagonal(:)]                            # g(ω = 1) diagonal on all contact orbitals
4×4 OrbitalSliceMatrix{ComplexF64,LinearAlgebra.Diagonal{ComplexF64, Vector{ComplexF64}}}:
 -0.10919-0.0839858im       0.0+0.0im             0.0+0.0im             0.0+0.0im
      0.0+0.0im        -0.10919-0.0839858im       0.0+0.0im             0.0+0.0im
      0.0+0.0im             0.0+0.0im        -0.10919-0.0839858im       0.0+0.0im
      0.0+0.0im             0.0+0.0im             0.0+0.0im        -0.10919-0.0839858im

julia&gt; g(1)[diagonal(:, kernel = SA[1 0; 0 -1])]    # σz spin density of the above
4×4 OrbitalSliceMatrix{ComplexF64,LinearAlgebra.Diagonal{ComplexF64, Vector{ComplexF64}}}:
 5.61885e-12+1.38778e-17im           0.0+0.0im
         0.0+0.0im          -5.61882e-12+2.77556e-17im</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`sitepairs`, `greenfunction`, `ldos`, `densitymatrix`, `OrbitalSliceArray`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL1798-L1839">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.energies" href="#Quantica.energies"><code>Quantica.energies</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">energies(sp::Spectrum)</code></pre><p>Returns the energies in <code>sp</code> as a vector of Numbers (not necessarily real). Equivalent to <code>first(sp)</code>.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`spectrum`, `bands`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL1407-L1414">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.gap" href="#Quantica.gap"><code>Quantica.gap</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Quantica.gap(h::Hamiltonian1D{T}, µ = 0; atol = eps(T), kw...)</code></pre><p>Compute the minimal gap around <code>µ</code>, see <code>Quantica.gaps</code></p><p><strong>See also:</strong></p><pre><code class="nohighlight hljs">`Quantica.gaps`, `Quantica.decay_lengths`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL2707-L2715">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.gaps" href="#Quantica.gaps"><code>Quantica.gaps</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Quantica.gaps(h::Hamiltonian1D{T}, µ = 0; atol = eps(T), kw...)</code></pre><p>Compute the energy gaps of a 1D Hamiltonian <code>h</code> at chemical potential <code>µ</code>. The result is a <code>Vector{T}</code> of the local minima of the <code>|ϵ(ϕ) - µ|</code>, where <code>ϵ(ϕ)</code> is the energy band closest to <code>µ</code> and <code>ϕ ∈ [-π,π]</code> is the Bloch phase. The <code>atol</code> parameter is the absolute tolerance used to determine the local minima versus <code>ϕ</code>, which are computed using the <code>Schur</code> solver for 1D Hamiltonians. The keywords <code>kw</code> are passed to the ArnoldiMethod <code>partialschur!</code> eigensolver (<code>kw = (; nev = 1)</code> by default).</p><p>The <code>LinearMaps</code> and <code>ArnoldiMethod</code> packages must be loaded to enable this functionality.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; using LinearMaps, ArnoldiMethod

julia&gt; h = LP.linear() |&gt; supercell(4) |&gt; hopping(1) - @onsite((r; U = 2) -&gt; ifelse(iseven(r[1]), U, -U));

julia&gt; Quantica.gaps(h(U=2))
2-element Vector{Float64}:
 1.9999999999999996
 1.9999999999999991</code></pre><p><strong>See also:</strong></p><pre><code class="nohighlight hljs">`Quantica.gap`, `Quantica.decay_lengths`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL2676-L2704">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.greenfunction" href="#Quantica.greenfunction"><code>Quantica.greenfunction</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">greenfunction(h::Union{AbstractHamiltonian,OpenHamiltonian}, solver::AbstractGreenSolver)</code></pre><p>Build a <code>g::GreenFunction</code> of Hamiltonian <code>h</code> using <code>solver</code>. See <code>GreenSolvers</code> for available solvers. If <code>solver</code> is not provided, a default solver is chosen automatically based on the type of <code>h</code>.</p><p><strong>Currying</strong></p><pre><code class="nohighlight hljs">h |&gt; greenfunction(solver)</code></pre><p>Curried form equivalent to <code>greenfunction(h, solver)</code>.</p><p><strong>Partial evaluation</strong></p><p><code>GreenFunction</code>s allow independent, partial evaluation of their positions (producing a <code>GreenSlice</code>) and energy/parameters (producing a <code>GreenSolution</code>). Depending on the solver, this may avoid repeating calculations unnecesarily when sweeping over either of these with the other fixed.</p><pre><code class="nohighlight hljs">g[ss]
g[siteselector(; ss...)]</code></pre><p>Build a <code>gs::GreenSlice</code> that represents a Green function at arbitrary energy and parameter values, but at specific sites on the lattice defined by <code>siteselector(; ss...)</code>, with <code>ss::NamedTuple</code> (see <code>siteselector</code>).</p><pre><code class="nohighlight hljs">g[contact_index::Integer]</code></pre><p>Build a <code>GreenSlice</code> equivalent to <code>g[contact_sites...]</code>, where <code>contact_sites...</code> correspond to sites in contact number <code>contact_index</code> (must have <code>1&lt;= contact_index &lt;= number_of_contacts</code>). See <code>attach</code> for details on attaching contacts to a Hamiltonian.</p><pre><code class="nohighlight hljs">g[:]</code></pre><p>Build a <code>GreenSlice</code> over all contacts.</p><pre><code class="nohighlight hljs">g[dst, src]</code></pre><p>Build a <code>gs::GreenSlice</code> between sites specified by <code>src</code> and <code>dst</code>, which can take any of the forms above. Therefore, all the previous single-index slice forms correspond to a diagonal block <code>g[i, i]</code>.</p><pre><code class="nohighlight hljs">g[diagonal(i; kernel = missing)]</code></pre><p>Build a diagonal <code>gs::GreenSlice</code> over sites specified by <code>i</code>. If <code>kernel = missing</code> the diagonal entries are <code>g[o, o]</code> for orbitals <code>o</code> in sites encoded in <code>i</code>. If <code>kernel</code> is a matrix, the diagonal elements are <code>tr(g[site, site] * kernel)</code> over each site <code>i</code>. Note that if there are several orbitals per site, <code>g[site, site]</code> may have different sizes (i.e. number of orbitals vs number of sites). Upon evaluating <code>gs(ω)</code>, the result is a <code>Diagonal</code> matrix wrapped in an <code>OrbitalSliceMatrix</code>, and spans full unit cells.See also <code>diagonal</code>.</p><pre><code class="nohighlight hljs">g[sitepairs(; kernel = missing, hops...)]</code></pre><p>Like the above but for a selection of site pairs selected by <code>hopselector(; hops...)</code>. Upon evaluating <code>gs(ω)</code>, the result is a <code>SparseMatrixCSC</code> wrapped in an <code>OrbitalSliceMatrix</code>, and spans full unit cells. See also <code>sitepairs</code>.</p><pre><code class="nohighlight hljs">g(ω; params...)</code></pre><p>Build a <code>gω::GreenSolution</code> that represents a retarded Green function at arbitrary points on the lattice, but at fixed energy <code>ω</code> and system parameter values <code>param</code>. If <code>ω</code> is complex, the retarded or advanced Green function is returned, depending on <code>sign(imag(ω))</code>. If <code>ω</code> is <code>Real</code>, a small, positive imaginary part is automatically added internally to produce the retarded <code>g</code>.</p><pre><code class="nohighlight hljs">gω[i]
gω[i, j]
gs(ω; params...)</code></pre><p>For any <code>gω::GreenSolution</code> or <code>gs::GreenSlice</code>, build the Green function matrix fully evaluated at fixed energy, parameters and positions. The matrix is a dense <code>m::OrbitalSliceMatrix</code> with scalar element type, so that any orbital structure on each site is flattened. Note that the resulting <code>m</code> can itself be indexed over collections of sites with <code>m[i, j]</code>, where <code>i, j</code> are <code>siteselector(; ss...)</code> or <code>ss::NamedTuple</code>.</p><pre><code class="nohighlight hljs">view(gω, i::C, j::C == i)</code></pre><p>For any <code>gω::GreenSolution</code> and <code>C&lt;:Union{Colon,Integer}</code>, obtain a view (of type <code>SubArray</code>, not <code>OrbitalSliceMatrix</code>) of the corresponding intra or inter-contact propagator <code>gω[i, j]</code> with minimal allocations.</p><pre><code class="nohighlight hljs">g(; params...)</code></pre><p>For any <code>g::Union{GreenFunction,GreenSlice}</code>, produce a new <code>GreenFunction</code> or <code>GreenSlice</code> with all parameters fixed to <code>params</code> (or to their default values if not provided).</p><p><strong>Full evaluation</strong></p><pre><code class="nohighlight hljs">gs(ω; params...)
gω[sites...]</code></pre><p>For <code>gs::GreenSlice</code> or <code>gω::GreenSolution</code>, return a fully evaluated <code>m::AbstractMatrix</code>. If the selected site slice was defined using <code>sites</code>, the concrete type of <code>m</code> will be will be a conventional <code>Matrix</code>-based type. Otherwise, it will be of type <code>OrbitalSliceMatrix</code>, an <code>AbstractMatrix</code> type that supports both conventional indexing and indexing with <code>sites</code> and <code>siteselectors</code>.</p><p>Advanced: in addition to the above, an unexported method <code>Quantica.call!(gs, ω; params...)</code> is provided to reuse the output matrix <code>m</code> (preallocated inside <code>gs</code>). Use with caution, as it may lead to unexpected aliasing</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = LP.honeycomb() |&gt; hamiltonian(@hopping((; t = 1) -&gt; t)) |&gt; supercell(region = RP.circle(10)) |&gt; greenfunction(GS.SparseLU())
GreenFunction{Float64,2,0}: Green function of a Hamiltonian{Float64,2,0}
  Solver          : AppliedSparseLUGreenSolver
  Contacts        : 0
  Contact solvers : ()
  Contact sizes   : ()
  ParametricHamiltonian{Float64,2,0}: Parametric Hamiltonian on a 0D Lattice in 2D space
    Bloch harmonics  : 1
    Harmonic size    : 726 × 726
    Orbitals         : [1, 1]
    Element type     : scalar (ComplexF64)
    Onsites          : 0
    Hoppings         : 2098
    Coordination     : 2.88981
    Parameters       : [:t]

julia&gt; gω = g(0.1; t = 2)
GreenSolution{Float64,2,0}: Green function at arbitrary positions, but at a fixed energy

julia&gt; ss = (; region = RP.circle(2), sublats = :B);

julia&gt; gs = g[ss]
GreenSlice{Float64,2,0}: Green function at arbitrary energy, but at a fixed lattice positions

julia&gt; gω[ss] == gs(0.1; t = 2)
true

julia&gt; summary(gω[ss])
&quot;14×14 OrbitalSliceMatrix{ComplexF64,Matrix{ComplexF64}}&quot;</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`GreenSolvers`, `diagonal`, `sitepairs`, `ldos`, `conductance`, `current`, `josephson`, `OrbitalSliceArray`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL1629-L1766">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.hamiltonian" href="#Quantica.hamiltonian"><code>Quantica.hamiltonian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hamiltonian(lat::Lattice, model; orbitals = 1)</code></pre><p>Create an <code>AbstractHamiltonian</code> (i.e. an <code>Hamiltonian</code> or <code>ParametricHamiltonian</code>) by applying <code>model</code> to the lattice <code>lat</code> (see <code>onsite</code>, <code>@onsite</code>, <code>hopping</code> and <code>@hopping</code> for details on building parametric and non-parametric tight-binding models).</p><pre><code class="nohighlight hljs">hamiltonian(lat::Lattice, model, modifiers...; orbitals = 1)</code></pre><p>Create a <code>ParametricHamiltonian</code> where all onsite and hopping terms in <code>model</code> can be parametrically modified through the provided parametric <code>modifiers</code> (see <code>@onsite!</code> and <code>@hopping!</code> for details on defining modifiers).</p><pre><code class="nohighlight hljs">hamiltonian(h::AbstractHamiltonian, modifier, modifiers...)</code></pre><p>Add modifiers to an existing <code>AbstractHamiltonian</code>.</p><pre><code class="nohighlight hljs">hamiltonian(h::ParametricHamiltonian)</code></pre><p>Return the base (non-parametric) <code>Hamiltonian</code> of <code>h</code>, with all modifiers and parametric model terms removed (see <code>@onsite</code>, <code>@hopping</code>, <code>@onsite!</code>, <code>@hopping!</code>).</p><p><strong>Keywords</strong></p><ul><li><code>orbitals</code>: number of orbitals per sublattice. If an <code>Integer</code> (or a <code>Val{&lt;:Integer}</code> for type-stability), all sublattices will have the same number of orbitals. A collection of values indicates the orbitals on each sublattice.</li></ul><p><strong>Currying</strong></p><pre><code class="nohighlight hljs">lat |&gt; hamiltonian(model[, modifiers...]; kw...)</code></pre><p>Curried form of <code>hamiltonian</code> equivalent to <code>hamiltonian(lat, model, modifiers...; kw...)</code>.</p><pre><code class="nohighlight hljs">lat |&gt; model</code></pre><p>Alternative and less general curried form equivalent to <code>hamiltonian(lat, model)</code>.</p><pre><code class="nohighlight hljs">h |&gt; modifier</code></pre><p>Alternative and less general curried form equivalent to <code>hamiltonian(h, modifier)</code>.</p><p><strong>Indexing</strong></p><pre><code class="nohighlight hljs">h[dn::SVector{L,Int}]
h[dn::NTuple{L,Int}]</code></pre><p>Return the Bloch harmonic of an <code>h::AbstractHamiltonian</code> in the form of a <code>SparseMatrixCSC</code> with complex scalar <code>eltype</code>. This matrix is &quot;flat&quot;, in the sense that it contains matrix elements between individual orbitals, not sites. This distinction is only relevant for multiorbital Hamiltonians. To access the non-flattened matrix use <code>h[unflat(dn)]</code> (see also <code>unflat</code>).</p><pre><code class="nohighlight hljs">h[()]</code></pre><p>Special syntax equivalent to <code>h[(0...)]</code>, which access the fundamental Bloch harmonic.</p><pre><code class="nohighlight hljs">h[i::CellSites, j::CellSites = i]</code></pre><p>With <code>i</code> and <code>j</code> of type <code>CellSites</code> and constructed with <code>sites([cell,] indices)</code>, return a <code>SparseMatrixCSC</code> block of <code>h</code> between the sites with the corresponding <code>indices</code> and in the given <code>cell</code>s. Alternatively, one can also use <code>view(h, i, j = i)</code>, which should be non-allocating for <code>AbstractHamiltonian</code>s with uniform number of orbitals.</p><pre><code class="nohighlight hljs">h[srow::SiteSelector, scol::SiteSelector = srow]
h[kwrow::NamedTuple, kwcol::NamedTuple = kwrow]</code></pre><p>Return an <code>OrbitalSliceMatrix</code> of <code>h</code> between row and column sites selected by <code>srow</code> and <code>scol</code>, or by <code>siteselector(; kwrow...)</code> and <code>siteselector(; kwcol...)</code></p><p>Note: <code>CellSites</code> and <code>SiteSelector</code>s can be mixed when indexing, in which case the matrix block will be returned as a <code>SparseMatrixCSC</code>, instead of an <code>OrbitalSliceMatrix</code>.</p><p><strong>Call syntax</strong></p><pre><code class="nohighlight hljs">ph(; params...)</code></pre><p>Return a <code>h::Hamiltonian</code> from a <code>ph::ParametricHamiltonian</code> by applying specific values to its parameters <code>params</code>. If <code>ph</code> is a non-parametric <code>Hamiltonian</code> instead, this is a no-op.</p><pre><code class="nohighlight hljs">h(φs; params...)</code></pre><p>Return the flat, sparse Bloch matrix of <code>h::AbstractHamiltonian</code> at Bloch phases <code>φs</code>, with applied parameters <code>params</code> if <code>h</code> is a <code>ParametricHamiltonian</code>. The Bloch matrix is defined as</p><pre><code class="nohighlight hljs">    H = ∑_dn exp(-im φs⋅dn) H_dn</code></pre><p>where <code>H_dn = h[dn]</code> is the <code>dn</code> flat Bloch harmonic of <code>h</code>, and <code>φs[i] = k⋅aᵢ</code> in terms of the wavevector <code>k</code> and the Bravais vectors <code>aᵢ</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h = hamiltonian(LP.honeycomb(), hopping(SA[0 1; 1 0], range = 1/√3), orbitals = 2)
Hamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5
  Harmonic size    : 2 × 2
  Orbitals         : [2, 2]
  Element type     : 2 × 2 blocks (ComplexF64)
  Onsites          : 0
  Hoppings         : 6
  Coordination     : 3.0

julia&gt; h((0,0))
4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:
     ⋅          ⋅      0.0+0.0im  3.0+0.0im
     ⋅          ⋅      3.0+0.0im  0.0+0.0im
 0.0+0.0im  3.0+0.0im      ⋅          ⋅
 3.0+0.0im  0.0+0.0im      ⋅          ⋅

julia&gt; h[sites(1), sites(2)]
2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:
 0.0+0.0im  1.0+0.0im
 1.0+0.0im  0.0+0.0im

julia&gt; ph = h |&gt; @hopping!((t; p = 3) -&gt; p*t); ph[region = RP.square(1)]
4×4 OrbitalSliceMatrix{ComplexF64,SparseArrays.SparseMatrixCSC{ComplexF64, Int64}}:
 0.0+0.0im  0.0+0.0im  0.0+0.0im  3.0+0.0im
 0.0+0.0im  0.0+0.0im  3.0+0.0im  0.0+0.0im
 0.0+0.0im  3.0+0.0im  0.0+0.0im  0.0+0.0im
 3.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`lattice`, `onsite`, `hopping`, `@onsite`, `@hopping`, `@onsite!`, `@hopping!`, `ishermitian`, `OrbitalSliceMatrix`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL604-L728">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.hopping" href="#Quantica.hopping"><code>Quantica.hopping</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hopping(t; hops...)
hopping((r, dr) -&gt; t(r, dr); hops...)</code></pre><p>Build a <code>TighbindingModel</code> representing a uniform or a position-dependent hopping amplitude, respectively, on hops selected by <code>hopselector(; hops...)</code> (see <code>hopselector</code> for details).</p><p>Hops from a site at position <code>r₁</code> to another at <code>r₂</code> are described using the hop center <code>r = (r₁ + r₂)/2</code> and the hop vector <code>dr = r₂ - r₁</code>. Hopping amplitudes <code>t</code> can be a <code>Number</code> (for hops between single-orbital sites), a <code>UniformScaling</code> (e.g. <code>2I</code>) or an <code>AbstractMatrix</code> (use <code>SMatrix</code> for performance) of dimensions matching the number of orbitals in the selected sites. Models may be applied to a lattice <code>lat</code> to produce an <code>Hamiltonian</code> with <code>hamiltonian(lat, model; ...)</code>, see <code>hamiltonian</code>. Position dependent models are forced to preserve the periodicity of the lattice.</p><pre><code class="nohighlight hljs">hopping(m::Union{TighbindingModel,ParametricModel}; hops...)</code></pre><p>Convert <code>m</code> into a new model with just hopping terms acting on <code>hops</code>.</p><p><strong>Model algebra</strong></p><p>Models can be combined using <code>+</code>, <code>-</code> and <code>*</code>, or conjugated with <code>&#39;</code>, e.g. <code>onsite(1) - 2 * hopping(1)&#39;</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = hopping((r, dr) -&gt; cis(dot(SA[r[2], -r[1]], dr)); dcells = (0,0)) + onsite(r -&gt; rand())
TightbindingModel: model with 2 terms
  HoppingTerm{Function}:
    Region            : any
    Sublattice pairs  : any
    Cell distances    : (0, 0)
    Hopping range     : Neighbors(1)
    Reverse hops      : false
    Coefficient       : 1
  OnsiteTerm{Function}:
    Region            : any
    Sublattices       : any
    Cells             : any
    Coefficient       : 1

julia&gt; LP.honeycomb() |&gt; supercell(2) |&gt; hamiltonian(model)
Hamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 1
  Harmonic size    : 8 × 8
  Orbitals         : [1, 1]
  Element type     : scalar (ComplexF64)
  Onsites          : 8
  Hoppings         : 16
  Coordination     : 2.0</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`onsite`, `@onsite`, `@hopping`, `@onsite!`, `@hopping!`, `hamiltonian`, `plusadjoint`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL797-L851">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.hopselector" href="#Quantica.hopselector"><code>Quantica.hopselector</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hopselector(; range = neighbors(1), dcells = missing, sublats = missing, region = missing)</code></pre><p>Return a <code>HopSelector</code> object that can be used to select a finite set of hops between sites in a lattice. Hops between two sites at positions <code>r₁ = r - dr/2</code> and <code>r₂ = r + dr</code>, belonging to unit cells with a cell distance <code>dn::SVector{L,Int}</code> and to a sublattices with names <code>s₁::Symbol</code> and <code>s₂::Symbol</code> will be selected only if</p><pre><code class="nohighlight hljs">`region(r, dr) &amp;&amp; (s₁ =&gt; s₂ in sublats) &amp;&amp; (dcell in dcells) &amp;&amp; (norm(dr) &lt;= range)`</code></pre><p>If any of these is <code>missing</code> it will not be used to constraint the selection.</p><p><strong>Generalization</strong></p><p>While <code>range</code> is usually a <code>Real</code>, and <code>sublats</code> and <code>dcells</code> are usually collections of <code>Pair{Symbol}</code>s and <code>SVector</code>s, respectively, they also admit other possibilities:</p><pre><code class="nohighlight hljs">sublats = :A                       # Hops from :A to :A
sublats = :A =&gt; :B                 # Hops from :A to :B sublattices, but not from :B to :A
sublats = (:A =&gt; :B,)              # Same as above
sublats = (:A =&gt; :B, :C =&gt; :D)     # Hopping from :A to :B or :C to :D
sublats = (:A, :C) .=&gt; (:B, :D)    # Broadcasted pairs, same as above
sublats = (:A, :C) =&gt; (:B, :D)     # Direct product, (:A=&gt;:B, :A=&gt;:D, :C=&gt;:B, :C=&gt;D)
sublats = 1 =&gt; 2                   # Hops from 1st to 2nd sublat. All the above patterns also admit Ints
sublats = (spec₁, spec₂, ...)      # Hops matching any of the specs with any of the above forms

dcells  = dn::SVector{L,Integer}   # Hops between cells separated by `dn`
dcells  = dn::NTuple{L,Integer}    # Hops between cells separated by `SVector(dn)`
dcells  = f::Function              # Hops between cells separated by `dn` such that `f(dn) == true`

range   = neighbors(n)             # Hops within the `n`-th nearest neighbor distance in the lattice
range   = (min, max)               # Hops at distance inside the `[min, max]` closed interval (bounds can also be `neighbors(n)`)</code></pre><p><strong>Usage</strong></p><p>Although the constructor <code>hopselector(; kw...)</code> is exported, the end user does not usually need to call it directly. Instead, the keywords <code>kw</code> are input into different functions that allow filtering hops, which themselves call <code>hopselector</code> internally as needed. Some of these functions are</p><pre><code class="nohighlight hljs">- hopping(...; kw...)   : hopping model term to be applied to site pairs specified by `kw`
- @hopping(...; kw...)  : parametric hopping model term to be applied to site pairs specified by `kw`
- @hopping!(...; kw...) : hopping modifier to be applied to site pairs specified by `kw`</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h = LP.honeycomb() |&gt; hamiltonian(hopping(1, range = neighbors(2), sublats = (:A, :B) .=&gt; (:A, :B)))
Hamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 7
  Harmonic size    : 2 × 2
  Orbitals         : [1, 1]
  Element type     : scalar (ComplexF64)
  Onsites          : 0
  Hoppings         : 12
  Coordination     : 6.0

julia&gt; h = LP.honeycomb() |&gt; hamiltonian(hopping(1, range = (neighbors(2), neighbors(3)), sublats = (:A, :B) =&gt; (:A, :B)))
Hamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 9
  Harmonic size    : 2 × 2
  Orbitals         : [1, 1]
  Element type     : scalar (ComplexF64)
  Onsites          : 0
  Hoppings         : 18
  Coordination     : 9.0</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`siteselector`, `lattice`, `hopping`, `@hopping`, `@hopping!`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL514-L585">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.integrand" href="#Quantica.integrand"><code>Quantica.integrand</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Quantica.integrand(J::Josephson{&lt;:JosephsonIntegratorSolver}, kBT = 0; params...)</code></pre><p>Return the complex integrand <code>d::JosephsonIntegrand</code> whose integral over frequency yields the Josephson current, <code>J(kBT; params...) = Re(∫dx d(x; params...))</code>, where <code>ω(x) = Quantica.point(x, d)</code> is a path parametrization over real variable <code>x</code> . To evaluate the <code>d</code> for a given <code>x</code>, use <code>d(x)</code>, or <code>call!(d, x)</code> for its mutating (non-allocating) version.</p><pre><code class="nohighlight hljs">Quantica.integrand(ρ::DensityMatrix{&lt;:DensityMatrixIntegratorSolver}, mu = 0, kBT = 0; params...)</code></pre><p>Like above for the density matrix <code>ρ</code>, with <code>d::DensityMatrixIntegrand</code>, so that <code>ρ(mu, kBT; params...) = -mat_imag(∫dω d(ω; params...))/π</code>, and <code>mat_imag(GF::Matrix) = (GF - GF&#39;)/2im</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL2265-L2278">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.josephson" href="#Quantica.josephson"><code>Quantica.josephson</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">josephson(gs::GreenSlice, path::AbstractIntegrationPath; opts..., quadgk_opts...)</code></pre><p>For a <code>gs = g[i::Integer]</code> slice of the <code>g::GreenFunction</code> of a hybrid junction, build a <code>J::Josephson</code> object representing the equilibrium (static) Josephson current <code>I_J</code> flowing into <code>g</code> through contact <code>i</code>. The algorithm relies on the integration of a function of <code>gs(ω)</code> (see below) along a contour in the complex-ω plane defined by <code>path</code> (see <code>Paths</code> for available options). Most integration paths employ the Cauchy theorem, and therefore assume that <code>gs(ω)</code> is fully analytic between the path and the real axis. This may not be true if <code>gs</code> contains user-defined contacts created using <code>attach(model)</code> with general ω-dependent models, but note that Quantica will not check for analyticity. Keywords <code>quadgk_opts</code> are passed to the <code>QuadGK.quadgk</code> integration routine.</p><p>The result of <code>I_J</code> is given in units of <code>qe/h</code> (<code>q</code> is the dimensionless carrier charge). <code>I_J</code> can be written as <span>$I_J = Re ∫ dω f(ω) j(ω)$</span>, where <span>$j(ω) = (qe/h) × 2Tr[(ΣʳᵢGʳ - GʳΣʳᵢ)τz]$</span>. Here <code>f(ω)</code> is the Fermi function with <code>µ = 0</code>.</p><pre><code class="nohighlight hljs">josephson(gs::GreenSlice, ωscale::Real; kw...)</code></pre><p>As above, but with <code>path = Paths.radial(ωscale, π/4)</code>, which computes josephson current by integrating the Green function from <code>ω = -Inf</code> to <code>ω = Inf</code> along a <code>ϕ = π/4</code> radial complex path, see <code>Paths</code> for details. Here <code>ωscale</code> should be some typical energy scale in the system, like the superconducting gap (the integration time may depend on <code>ωscale</code>, but not the result).</p><pre><code class="nohighlight hljs">josephson(gs::GreenSlice, ωs::NTuple{N,Real}; kw...)</code></pre><p>As above, but with a <code>path = Paths.sawtooth(ωs)</code>, which uses a sawtooth-shaped path touching points <code>ωs</code> on the real axes. Ideally, these values should span the full system bandwidth.</p><p><strong>Full evaluation</strong></p><pre><code class="nohighlight hljs">J(kBT = 0; params...)   # where J::Josephson</code></pre><p>Evaluate the current <code>I_J</code> at chemical potemtial <code>µ = 0</code> and temperature <code>kBT</code> (in the same units as the Hamiltonian) for the given <code>g</code> parameters <code>params</code>, if any.</p><p><strong>Keywords</strong></p><p>The generic integration algorithm allows for the following <code>opts</code> (see also <code>densitymatrix</code>):</p><ul><li><code>phases</code> : collection of superconducting phase biases to apply to the contact, so as to efficiently compute the full current-phase relation <code>[I_J(ϕ) for ϕ in phases]</code>. Note that each phase bias <code>ϕ</code> is applied by a <code>[cis(-ϕ/2)*I 0*I; 0*I cis(ϕ/2)*I]</code> rotation to the self energy, which is almost free. If <code>missing</code>, a single <code>I_J</code> is returned.</li><li><code>omegamap</code>: a function <code>ω -&gt; (; params...)</code> that translates <code>ω</code> at each point in the integration contour to a set of system parameters. Useful for <code>ParametricHamiltonians</code> which include terms <code>Σ(ω)</code> that depend on a parameter <code>ω</code> (one would then use <code>omegamap = ω -&gt; (; ω)</code>). Default: <code>ω -&gt; (;)</code>, i.e. no mapped parameters.</li><li><code>callback</code>: a function to be called as <code>callback(xs..., y)</code> at each point in the integration, where <code>xs</code> is the integration point (e.g. <code>xs = (ω,)</code> along a contour) and <code>y</code> is the integrand evaluated at that point. Useful for inspection and debugging, e.g. <code>callback(x, y) = @show x</code>. Default: <code>Returns(nothing)</code>.</li><li><code>atol</code>: absolute integration tolerance. The default <code>1e-7</code> is chosen to avoid excessive integration times when the current is actually zero. Default <code>1e-7</code>.</li></ul><p>The <code>quadgk_opts</code> are extra keyword arguments (other than <code>atol</code>) to pass on to the function <code>QuadGK.quadgk</code> that is used for the integration.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; glead = LP.square() |&gt; hamiltonian(@onsite((; ω = 0) -&gt; 0.0005 * SA[0 1; 1 0] + im*ω*I) + hopping(SA[1 0; 0 -1]), orbitals = 2) |&gt; supercell((1,0), region = r-&gt;-2&lt;r[2]&lt;2) |&gt; greenfunction(GS.Schur(boundary = 0));

julia&gt; g0 = LP.square() |&gt; hamiltonian(hopping(SA[1 0; 0 -1]), orbitals = 2) |&gt; supercell(region = r-&gt;-2&lt;r[2]&lt;2 &amp;&amp; r[1]≈0) |&gt; attach(glead, reverse = true) |&gt; attach(glead) |&gt; greenfunction;

julia&gt; J = josephson(g0[1], 0.0005; omegamap = ω -&gt; (;ω), phases = subdiv(0, pi, 10))
Josephson: equilibrium Josephson current at a specific contact using solver of type JosephsonIntegratorSolver

julia&gt; J(0.0)
10-element Vector{Float64}:
 1.0130103834038537e-15
 0.0008178802022977883
 0.0016109471548779466
 0.0023551370133118215
 0.0030278625151304614
 0.003608696305848759
 0.00407998998248311
 0.0044274100715435295
 0.004640372460465891
 5.179773035314182e-12</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`greenfunction`, `densitymatrix`, `ldos`, `current`, `conductance`, `transmission`, `OrbitalSliceArray`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL2188-L2262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.lattice" href="#Quantica.lattice"><code>Quantica.lattice</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lattice(sublats::Sublat...; bravais = (), dim, type, names)
lattice(sublats::AbstractVector{&lt;:Sublat}; bravais = (), dim, type, names)</code></pre><p>Create a <code>Lattice{T,E,L}</code> from sublattices <code>sublats</code>, where <code>L</code> is the number of Bravais vectors given by <code>bravais</code>, <code>T = type</code> is the <code>AbstractFloat</code> type of spatial site coordinates, and <code>dim = E</code> is the spatial embedding dimension.</p><pre><code class="nohighlight hljs">lattice(lat::Lattice; bravais = missing, dim = missing, type = missing, names = missing)</code></pre><p>Create a new lattice by applying any non-missing keywords to <code>lat</code>.</p><pre><code class="nohighlight hljs">lattice(x)</code></pre><p>Return the parent lattice of object <code>x</code>, of type e.g. <code>LatticeSlice</code>, <code>Hamiltonian</code>, etc.</p><p><strong>Keywords</strong></p><ul><li><code>bravais</code>: a collection of one or more Bravais vectors of type NTuple{E} or SVector{E}. It can also be an <code>AbstractMatrix</code> of dimension <code>E×L</code>. The default <code>bravais = ()</code> corresponds to a bounded lattice with no Bravais vectors.</li><li><code>names</code>: a collection of Symbols. Can be used to rename <code>sublats</code>. Any repeated names will be replaced if necessary by <code>:A</code>, <code>:B</code> etc. to ensure that all sublattice names are unique.</li></ul><p><strong>Indexing</strong></p><pre><code class="nohighlight hljs">lat[kw...]
lat[siteselector(; kw...)]</code></pre><p>Indexing into a lattice <code>lat</code> with keywords returns <code>LatticeSlice</code> representing a finite collection of sites selected by <code>siteselector(; kw...)</code>. See <code>siteselector</code> for details on possible <code>kw</code>, and <code>sites</code> to obtain site positions.</p><pre><code class="nohighlight hljs">lat[]</code></pre><p>Special case equivalent to <code>lat[cells = (0,...)]</code> that returns a <code>LatticeSlice</code> of the zero-th unitcell.</p><pre><code class="nohighlight hljs">lat[i::CellSites]</code></pre><p>With an <code>i</code> of type <code>CellSites</code> contructed with <code>sites([cell,] indices)</code>, return a <code>LatticeSlice</code> of the corresponding sites.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; lat = lattice(sublat((0, 0)), sublat((0, 1)); bravais = (1, 0), type = Float32, dim = 3, names = (:up, :down))
Lattice{Float32,3,1} : 1D lattice in 3D space
  Bravais vectors : Vector{Float32}[[1.0, 0.0, 0.0]]
  Sublattices     : 2
    Names         : (:up, :down)
    Sites         : (1, 1) --&gt; 2 total per unit cell

julia&gt; lattice(lat; type = Float64, names = (:A, :B), dim = 2)
Lattice{Float64,2,1} : 1D lattice in 2D space
  Bravais vectors : [[1.0, 0.0]]
  Sublattices     : 2
    Names         : (:A, :B)
    Sites         : (1, 1) --&gt; 2 total per unit cell</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`LatticePresets`, `sublat`, `sites`, `supercell`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL163-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.ldos" href="#Quantica.ldos"><code>Quantica.ldos</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ldos(gs::GreenSlice; kernel = missing)</code></pre><p>Build <code>ρs::LocalSpectralDensitySlice</code>, a partially evaluated object representing the local density of states <code>ρᵢ(ω)</code> at specific sites <code>i</code> but at arbitrary energy <code>ω</code>.</p><pre><code class="nohighlight hljs">ldos(gω::GreenSolution; kernel = missing)</code></pre><p>Build <code>ρω::LocalSpectralDensitySolution</code>, as above, but for <code>ρᵢ(ω)</code> at a fixed <code>ω</code> and arbitrary sites <code>i</code>. See also <code>greenfunction</code> for details on building a <code>GreenSlice</code> and <code>GreenSolution</code>.</p><p>The local density of states is defined here as <span>$ρᵢ(ω) = -Tr(gᵢᵢ(ω))/π$</span>, where <code>gᵢᵢ(ω)</code> is the retarded Green function at a given site <code>i</code>.</p><p><strong>Keywords</strong></p><ul><li><code>kernel</code> : for multiorbital sites, <code>kernel</code> allows to compute a generalized <code>ldos</code> <code>ρᵢ(ω) = -imag(Tr(gᵢᵢ(ω) * kernel))/π</code>, where <code>gᵢᵢ(ω)</code> is the retarded Green function at site <code>i</code> and energy <code>ω</code>. If <code>kernel = missing</code>, the complete, orbital-resolved <code>ldos</code> is returned. Default: <code>missing</code></li></ul><p><strong>Full evaluation</strong></p><pre><code class="nohighlight hljs">ρω[sites...]
ρs(ω; params...)</code></pre><p>Given a partially evaluated <code>ρω::LocalSpectralDensitySolution</code> or <code>ρs::LocalSpectralDensitySlice</code>, build an <code>OrbitalSliceVector</code> <code>[ρ₁(ω), ρ₂(ω)...]</code> of fully evaluated local densities of states. See <code>OrbitalSliceVector</code> for further details.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; g = HP.graphene(a0 = 1, t0 = 1) |&gt; supercell(region = RP.circle(20)) |&gt; attach(nothing, region = RP.circle(1)) |&gt; greenfunction(GS.KPM(order = 300, bandrange = (-3.1, 3.1)))
GreenFunction{Float64,2,0}: Green function of a Hamiltonian{Float64,2,0}
  Solver          : AppliedKPMGreenSolver
  Contacts        : 1
  Contact solvers : (SelfEnergyEmptySolver,)
  Contact sizes   : (6,)
  Hamiltonian{Float64,2,0}: Hamiltonian on a 0D Lattice in 2D space
    Bloch harmonics  : 1
    Harmonic size    : 2898 × 2898
    Orbitals         : [1, 1]
    Element type     : scalar (ComplexF64)
    Onsites          : 0
    Hoppings         : 8522
    Coordination     : 2.94065

julia&gt; ldos(g(0.2))[1]
6-element OrbitalSliceVector{Float64,Vector{Float64}}:
 0.036802204179316955
 0.034933055722650375
 0.03493305572265026
 0.03493305572265034
 0.03493305572265045
 0.036802204179317045

julia&gt; ldos(g(0.2))[1] == -imag.(diag(g[diagonal(1)](0.2))) ./ π
true</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`greenfunction`, `diagonal`, `current`, `conductance`, `josephson`, `transmission`, `OrbitalSliceVector`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL1881-L1942">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.meanfield" href="#Quantica.meanfield"><code>Quantica.meanfield</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">meanfield(g::GreenFunction, args...; kw...)</code></pre><p>Build a <code>M::MeanField</code> object that can be used to compute the Hartree-Fock-Bogoliubov mean field <code>Φ</code> between selected sites interacting through a given charge-charge potential. The density matrix used to build the mean field is obtained with <code>densitymatrix(g[pair_selection], args...; kw...)</code>, see <code>densitymatrix</code> for details.</p><p>The mean field between site <code>i</code> and <code>j</code> is defined as <code>Φᵢⱼ = δᵢⱼ hartreeᵢ + fockᵢⱼ</code>, where</p><pre><code class="nohighlight hljs">hartreeᵢ = ν * Q * Σ_k v_H(r_i-r_k) * tr(ρ[k,k]*Q)
fockᵢⱼ  = -v_F(r_i-r_j) * Q * ρ[i,j] * Q</code></pre><p>Here <code>Q</code> is the charge operator, <code>v_H</code> and <code>v_F</code> are Hartree and Fock interaction potentials, and <code>ρ</code> is the density matrix evaluated at specific chemical potential and temperature. Also <code>ν = ifelse(nambu, 0.5, 1.0)</code>, and <code>v_F(0) = v_H(0) = U</code>, where <code>U</code> is the onsite interaction.</p><p><strong>Keywords</strong></p><ul><li><code>potential</code>: charge-charge potential to use for both Hartree and Fock. Can be <code>nothing</code>, a number, a function of position or a non-parametric model. Default: <code>1</code></li><li><code>hartree</code>: charge-charge potential <code>v_H</code> for the Hartree mean field. Can be <code>nothing</code>, a number, a function of position or a non-parametric model. Overrides <code>potential</code>. Default: <code>potential</code></li><li><code>fock</code>: charge-charge potential <code>v_F</code> for the Fock mean field. Can be <code>nothing</code>, a number, a function of position or a non-parametric model. Default: <code>hartree</code></li><li><code>onsite</code>: charge-charge onsite potential. If not <code>missing</code> it overrides both Hartree and Fock potentials for onsite interactions (unless they are <code>nothing</code>). Default: <code>missing</code></li><li><code>charge</code>: a number (in single-orbital systems) or a matrix (in multi-orbital systems) representing the charge operator on each site. Default: <code>I</code></li><li><code>nambu::Bool</code>: specifies whether the model is defined in Nambu space. In such case, <code>charge</code> should also be in Nambu space, typically <code>SA[1 0; 0 -1]</code> or similar. Default: <code>false</code></li><li><code>namburotation::Bool</code>: if <code>nambu == true</code> and spinful systems, specifies whether the spinor basis is <code>[c↑, c↓, c↓⁺, -c↑⁺]</code> (<code>namburotation = true</code>) or <code>[c↑, c↓, c↑⁺, c↓⁺]</code> (<code>namburotation = false</code>). Default: <code>false</code></li><li><code>selector::NamedTuple</code>: a collection of <code>hopselector</code> directives that defines the pairs of sites (<code>pair_selection</code> above) that interact through the charge-charge potential. Default: <code>(; range = 0)</code> (i.e. only onsite)</li><li><code>selector_hartree::NamedTuple</code>: same as <code>selector</code>, but restricted to the Hartree interactions. Useful e.g. to do efficient Hartree-only simulations: a long-range <code>selector_hartree</code> is cheap in periodic systems, as lattice periodicity is exploited to make the computational cost independent of the range. Default: <code>selector</code>.</li><li><code>selector_fock::NamedTuple</code>: same as <code>selector_hartree</code>, but for Fock interactions. Note that <code>selector_fock</code> increases the number of entries that need to be computed for the density matrix, so increasing the Fock range is typically not cheap. Default: <code>selector</code>.</li></ul><p>Any additional keywords <code>kw</code> are passed to the <code>densitymatrix</code> function used to compute the mean field, see above</p><p>If a non-parametric <code>TightbindingModel</code> is passed to the <code>potential</code>, <code>hartree</code> and/or <code>fock</code> keywords, the model will be used to define the interaction, by translating <code>onsite</code> terms into onsite interactions, and <code>hopping</code> terms into inter-site interactions. In such case, the corresponding <code>selector_hartree</code> and/or <code>selector_fock</code> will be ignored. See <code>onsite</code> and <code>hopping</code> for details on defining non-parametric models.</p><p><strong>Evaluation and Indexing</strong></p><pre><code class="nohighlight hljs">M(µ = 0, kBT = 0; params...)    # where M::MeanField</code></pre><p>Build an <code>Φ::CompressedOrbitalMatrix</code>, which is a special form of <code>OrbitalSliceMatrix</code> that can be indexed at pairs of individual sites, e.g. <code>ϕ[sites(2), sites(1)]</code> to return an <code>SMatrix</code>. This type of matrix is less flexible than <code>OrbitalSliceMatrix</code> but is fully static, and can encode symmetries. Its features are implementation details and are bound to change. The returned <code>Φ</code> is just meant to be used in non-spatial models, see Examples below.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = hopping(I) - @onsite((i; phi = zerofield) --&gt; phi[i]);  # see zerofield docstring

julia&gt; g = LP.honeycomb() |&gt; hamiltonian(model, orbitals = 2) |&gt; supercell((1,-1)) |&gt; greenfunction;

julia&gt; M = meanfield(g; selector = (; range = 1), charge = I, potential = 0.05)
MeanField{SMatrix{2, 2, ComplexF64, 4}} : builder of Hartree-Fock-Bogoliubov mean fields
  Charge type      : 2 × 2 blocks (ComplexF64)
  Hartree pairs    : 14
  Mean field pairs : 28
  Nambu            : false

julia&gt; phi0 = M(0.2, 0.3);

julia&gt; phi0[sites(1), sites(2)] |&gt; Quantica.chopsmall
2×2 SMatrix{2, 2, ComplexF64, 4} with indices SOneTo(2)×SOneTo(2):
 0.00109527+0.0im         0.0+0.0im
        0.0+0.0im  0.00109527+0.0im

julia&gt; phi0[sites(1)] |&gt; Quantica.chopsmall
2×2 SMatrix{2, 2, ComplexF64, 4} with indices SOneTo(2)×SOneTo(2):
 0.296672+0.0im       0.0+0.0im
      0.0+0.0im  0.296672+0.0im

julia&gt; phi1 = M(0.2, 0.3; phi = phi0);

julia&gt; phi1[sites(1), sites(2)] |&gt; Quantica.chopsmall
2×2 SMatrix{2, 2, ComplexF64, 4} with indices SOneTo(2)×SOneTo(2):
 0.00307712+0.0im         0.0+0.0im
        0.0+0.0im  0.00307712+0.0im</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`zerofield`, `densitymatrix`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL2742-L2828">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.neighbors" href="#Quantica.neighbors"><code>Quantica.neighbors</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">neighbors(n::Int)</code></pre><p>Create a <code>Neighbors(n)</code> object that represents a hopping range to distances corresponding to the n-th nearest neighbors in a given lattice, irrespective of their sublattice. Neighbors at equal distance do not count towards <code>n</code>.</p><pre><code class="nohighlight hljs">neighbors(n::Int, lat::Lattice)</code></pre><p>Obtain the actual nth-nearest-neighbot distance between sites in lattice <code>lat</code>.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`hopping`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL588-L601">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.onsite" href="#Quantica.onsite"><code>Quantica.onsite</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">onsite(o; sites...)
onsite(r -&gt; o(r); sites...)</code></pre><p>Build a <code>TighbindingModel</code> representing a uniform or a position-dependent onsite potential, respectively, on sites selected by <code>siteselector(; sites...)</code> (see <code>siteselector</code> for details).</p><p>Site positions are <code>r::SVector{E}</code>, where <code>E</code> is the embedding dimension of the lattice. The onsite potential <code>o</code> can be a <code>Number</code> (for single-orbital sites), a <code>UniformScaling</code> (e.g. <code>2I</code>) or an <code>AbstractMatrix</code> (use <code>SMatrix</code> for performance) of dimensions matching the number of orbitals in the selected sites. Models may be applied to a lattice <code>lat</code> to produce a <code>Hamiltonian</code> with <code>hamiltonian(lat, model; ...)</code>, see <code>hamiltonian</code>. Position dependent models are forced to preserve the periodicity of the lattice.</p><pre><code class="nohighlight hljs">onsite(m::{TighbindingModel,ParametricModel}; sites...)</code></pre><p>Convert <code>m</code> into a new model with just onsite terms acting on <code>sites</code>.</p><p><strong>Model algebra</strong></p><p>Models can be combined using <code>+</code>, <code>-</code> and <code>*</code>, or conjugated with <code>&#39;</code>, e.g. <code>onsite(1) - 2 * hopping(1)&#39;</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = onsite(r -&gt; norm(r) * SA[0 1; 1 0]; sublats = :A) - hopping(I; range = 2)
TightbindingModel: model with 2 terms
  OnsiteTerm{Function}:
    Region            : any
    Sublattices       : A
    Cells             : any
    Coefficient       : 1
  HoppingTerm{LinearAlgebra.UniformScaling{Bool}}:
    Region            : any
    Sublattice pairs  : any
    Cell distances    : any
    Hopping range     : 2.0
    Reverse hops      : false
    Coefficient       : -1

julia&gt; LP.cubic() |&gt; supercell(4) |&gt; hamiltonian(model, orbitals = 2)
Hamiltonian{Float64,3,3}: Hamiltonian on a 3D Lattice in 3D space
  Bloch harmonics  : 27
  Harmonic size    : 64 × 64
  Orbitals         : [2]
  Element type     : 2 × 2 blocks (ComplexF64)
  Onsites          : 64
  Hoppings         : 2048
  Coordination     : 32.0</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`hopping`, `@onsite`, `@hopping`, `@onsite!`, `@hopping!`, `hamiltonian`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL740-L794">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.orbaxes" href="#Quantica.orbaxes"><code>Quantica.orbaxes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">orbaxes(A::OrbitalSliceArray)</code></pre><p>Return the orbital axes of <code>A</code>. This is a tuple of <code>OrbitalSliceGrouped</code> objects that can be used e.g. to index another <code>OrbitalSliceArray</code> or to inspect the indices of each site with <code>siteindexdict</code>.</p><pre><code class="nohighlight hljs">orbaxes(A::OrbitalSliceArray, n)</code></pre><p>Like the above, but return only the n-th orbital axis</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; g = HP.graphene(orbitals = 2) |&gt; supercell((1,-1)) |&gt; greenfunction;

julia&gt; d = ldos(g[cells = SA[0]])(2); summary(d)
&quot;8-element OrbitalSliceVector{Float64,Vector{Float64}}&quot;

julia&gt; a = only(orbaxes(d))
OrbitalSliceGrouped{Float64,2,1} : collection of subcells of orbitals (grouped by sites) for a 1D lattice in 2D space
  Cells       : 1
  Cell range  : ([0], [0])
  Total sites : 4

julia&gt; siteindexdict(a)
4-element Dictionaries.Dictionary{Quantica.CellIndices{1, Int64, Quantica.SiteLike}, UnitRange{Int64}}:
 CellSites{1,Int64} : 1 site in cell zero
  Sites : 1 │ 1:2
 CellSites{1,Int64} : 1 site in cell zero
  Sites : 2 │ 3:4
 CellSites{1,Int64} : 1 site in cell zero
  Sites : 3 │ 5:6
 CellSites{1,Int64} : 1 site in cell zero
  Sites : 4 │ 7:8</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`siteindexdict`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL2419-L2458">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.plusadjoint" href="#Quantica.plusadjoint"><code>Quantica.plusadjoint</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plusadjoint(t::Model)</code></pre><p>Returns a model <code>t + t&#39;</code>. This is a convenience function analogous to the <code>+ h.c.</code> notation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = hopping(im, sublats = :A =&gt; :B) |&gt; plusadjoint
TightbindingModel: model with 2 terms
  HoppingTerm{Complex{Bool}}:
    Region            : any
    Sublattice pairs  : :A =&gt; :B
    Cell distances    : any
    Hopping range     : Neighbors(1)
    Reverse hops      : false
    Coefficient       : 1
  HoppingTerm{Complex{Int64}}:
    Region            : any
    Sublattice pairs  : :A =&gt; :B
    Cell distances    : any
    Hopping range     : Neighbors(1)
    Reverse hops      : true
    Coefficient       : 1

julia&gt; h = hamiltonian(LP.honeycomb(), model)
Hamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5
  Harmonic size    : 2 × 2
  Orbitals         : [1, 1]
  Element type     : scalar (ComplexF64)
  Onsites          : 0
  Hoppings         : 6
  Coordination     : 3.0

julia&gt; h((0,0))
2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:
     ⋅      0.0-3.0im
 0.0+3.0im      ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL1121-L1161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.points" href="#Quantica.points"><code>Quantica.points</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Quantica.points(O::Josephson, args...)
Quantica.points(O::DensityMatrix, args...)</code></pre><p>Return the vertices of the integration path used to compute <code>O(args...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL2281-L2286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.serialize" href="#Quantica.serialize"><code>Quantica.serialize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">serialize(as::AppliedSerializer{T}; params...)</code></pre><p>Construct a <code>Vector{T}</code> that encodes a selection of matrix elements of <code>h(; params...)</code> where <code>h = Quantica.parent_hamiltonian(as)</code> is the <code>AbstractHamiltonian</code> used to build the <code>AppliedSerializer</code>, see <code>serializer</code>.</p><pre><code class="nohighlight hljs">serialize(m::OrbitalSliceArray)</code></pre><p>Return an <code>Array</code> of the same eltype as <code>m</code> that contains all the stored matrix elements of <code>m</code>. See <code>deserialize</code> for the inverse operation.</p><pre><code class="nohighlight hljs">serialize(T::Type, m::OrbitalSliceArray)</code></pre><p>Reinterpret <code>serialize(m)</code> as a collection with eltype <code>T</code></p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`serializer`, `serialize!`, `deserialize`, `deserialize!`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL2586-L2605">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.serialize!" href="#Quantica.serialize!"><code>Quantica.serialize!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">serialize!(v, as::AppliedSerializer; params...)</code></pre><p>Fill <code>v</code> in-place with the output of <code>serialize(as; params...)</code>, see <code>serialize</code> for details.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`serialize`, `serialize!`, `deserialize`, `deserialize!`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL2608-L2616">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.serializer" href="#Quantica.serializer"><code>Quantica.serializer</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">serializer(T::Type, selectors...; parameter = :stream, encoder = identity, decoder = identity)</code></pre><p>Construct a abstract <code>s::Serializer</code> object defines the rules to serialize and deserialize an AbstractHamiltonian, i.e. to translate the matrix elements selected by <code>selectors</code> (<code>SiteSelectors</code> or <code>HopSelectors</code>) into a 1D array of scalars of type <code>T</code>.</p><pre><code class="nohighlight hljs">serializer(T::Type; kw...)</code></pre><p>Equivalent to <code>serializer(T, siteselector(), hopselector(); kw...)</code>, i.e. with all onsites and hoppings included in selection.</p><pre><code class="nohighlight hljs">serializer(T::Type, h::AbstractHamiltonian, selectors...; kw...)</code></pre><p>Applies a <code>Serializer</code> object like those above, and applies it to <code>h::AbstractHamiltonian</code> to produce an <code>AppliedSerializer{T,&lt;:AbstractHamiltonian}</code>, that can be used to serialize and deserialize <code>h</code>. See <code>serialize</code> and <code>deserialize</code> for further details.</p><pre><code class="nohighlight hljs">serializer(h::AbstractHamiltonian{T}, selectors...; kw...)</code></pre><p>Equivalent to <code>serializer(Complex{T}, h, selectors...; kw...)</code>.</p><p><strong>Keywords</strong></p><ul><li><code>parameter</code>: the parameter name used to address the serialized vector after transforming an <code>AppliedSerializer</code> into a <code>ParametricHamiltonian</code>, see below. Default: <code>:stream</code>.</li><li><code>encoder</code>: a function <code>s -&gt; vec</code> that translates a single matrix element <code>s</code> into an collection <code>vec</code> of scalars of type <code>T</code>. Also supported is <code>encoder = (s-&gt;vec, (s,s´)-&gt;vec´)</code>, which applies the second function to hoppings <code>hᵢⱼ = s</code> and their adjoint <code>hⱼᵢ = s´</code> to encode both in a single collection <code>vec´</code> (onsites <code>hᵢᵢ</code> are still encoded using the first single-argument function). This is useful for Hermitian Hamiltonians, where <code>hⱼᵢ</code> can be derived from <code>hᵢⱼ</code>. Default: <code>identity</code>.</li><li><code>decoder</code>: the inverse function <code>vec -&gt; s</code> of the encoder. If <code>encoder</code> is a tuple, <code>decoder</code> should also be a tuple of the inverse functions of each encoder function. Default: <code>identity</code>.</li></ul><p>Note: for an <code>h::AbstractHamiltonian</code> with a non-uniform number of orbitals, the matrix element passed to the <code>encoder</code> should always be assumed to be a square <code>SMatrix</code> of a fixed size that can fit all sites, padded with zeros if necessary (see &quot;Element type&quot; when displaying it, and the output of <code>h[unflat(dn)]</code>). Likewise, the decoder should return a square <code>SMatrix</code> of the same size, or any other container that can be converted to one. The latter is also important in cases with a uniform orbital number greater than one (non-scalar element type).</p><p>The user can check that the encoder and decoder are mutual inverses with <code>Quantica.check(s; params...)</code> where <code>params</code> is any choice of Hamiltonian parameters. This essentially checks that <code>h(; params) == deserialize(s, serialize(s; params...); params...)</code> holds.</p><p><strong>Call syntax and ParametricHamiltonians</strong></p><pre><code class="nohighlight hljs">as(; params...)</code></pre><p>Transforms <code>as::AppliedSerializer{T,&lt;:ParametricHamiltonian}</code> into an <code>as´::AppliedSerializer{T,&lt;:Hamiltonian}</code> where the enclosed <code>h</code> is replaced by <code>h´ = h(; params...)</code>. The in-place (aliasing) version of the above is <code>Quantica.call!(as; params...)</code>. Note that the enclosed <code>AbstractHamiltonian</code>s can be retrieved with e.g. <code>Quantica.parent_hamiltonian(as)</code>.</p><pre><code class="nohighlight hljs">hamiltonian(as::AppliedSerializer)</code></pre><p>Builds a <code>ph::ParametricHamiltonian</code> by adding <code>as</code> as a parametric modifier (similar to <code>@onsite!</code> or <code>@hopping!</code>) to the <code>h::AbstractHamiltonian</code> enclosed in <code>as</code>. As a result, <code>ph</code> acquires a new parameter of the name given by the <code>parameter</code> keyword specified originally (<code>:stream</code> by default, see above). This parameter takes a serialized stream (e.g. the output of <code>serialize(as)</code>) and replaces the corresponding elements in <code>ph</code>.</p><pre><code class="nohighlight hljs">h |&gt; s</code></pre><p>For <code>s::Serializer</code> and <code>h::AbstractHamiltonian</code>, converts <code>s</code> into an <code>as::AppliedSerializer</code> by applying it to <code>h</code> and then adds <code>as</code> as a parametric modifier to <code>h</code> to produce a <code>ph::ParametricHamiltonian</code>, as above. Note that <code>h |&gt; as</code> with <code>as::AppliedSerializer</code> is not allowed, since <code>as</code> can only be a modifier of its enclosed <code>AbstractHamiltonian</code>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; h1 = LP.linear() |&gt; hopping((r, dr) -&gt; im*dr[1]) - @onsite((r; U = 2) -&gt; U);

julia&gt; as = serializer(Float64, h1; encoder = s -&gt; reim(s), decoder = v -&gt; complex(v[1], v[2]))
AppliedSerializer : translator between a selection of of matrix elements of an AbstractHamiltonian and a collection of scalars
  Object            : ParametricHamiltonian
  Object parameters : [:U]
  Stream parameter  : :stream
  Output eltype     : Float64
  Encoder/Decoder   : Single
  Length            : 6

julia&gt; v = serialize(as; U = 4)
6-element Vector{Float64}:
 -4.0
  0.0
 -0.0
 -1.0
  0.0
  1.0

julia&gt; h2 = deserialize!(as, v);

julia&gt; h2 == h1(U = 4)
true

julia&gt; h3 = hamiltonian(as)
ParametricHamiltonian{Float64,1,1}: Parametric Hamiltonian on a 1D Lattice in 1D space
  Bloch harmonics  : 3
  Harmonic size    : 1 × 1
  Orbitals         : [1]
  Element type     : scalar (ComplexF64)
  Onsites          : 1
  Hoppings         : 2
  Coordination     : 2.0
  Parameters       : [:U, :stream]

julia&gt; h3(stream = v, U = 5) == h1(U = 4)  # stream overwrites the U=5 onsite terms
true</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`serialize`, `serialize!`, `deserialize`, `deserialize!`, `siteselector`, `hopselector`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL2472-L2583">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.siteindexdict" href="#Quantica.siteindexdict"><code>Quantica.siteindexdict</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">siteindexdict(axis::OrbitalSliceGrouped)</code></pre><p>Return a dictionary of <code>CellSite</code>s representing single sites in an orbital axis of an <code>OrbitalSliceArray</code>, typically obtained with <code>orbaxes</code>. See <code>orbaxes</code> for an example.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`orbaxes`, `OrbitalSliceArray`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL2461-L2469">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.sitepairs" href="#Quantica.sitepairs"><code>Quantica.sitepairs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sitepairs(s::HopSelector; kernel = missing)</code></pre><p>Create a selection of site pairs <code>s::SparseIndices</code> used to sparsely index into a <code>g::GreenFunction</code> or <code>g::GreenSolution</code>, as <code>g[s]</code>. Of the resulting <code>OrbitalSliceMatrix</code> only the selected pairs of matrix elements will be computed, leaving the rest as zero (sparse matrix). The sparse matrix spans the minimum number of complete unit cells to include all site pairs.</p><p>Tip: if onsite terms are required use <code>includeonsite = true</code> as a keyword in <code>s</code>.</p><p>If <code>kernel = Q</code> (a matrix instead of <code>missing</code>), each of these site blocks <code>gᵢⱼ</code> will be replaced by <code>Tr(kernel * gᵢⱼ)</code>.</p><pre><code class="nohighlight hljs">sitepairs(; kernel = missing, hops...)</code></pre><p>Equivalent to <code>sitepairs(hopselector(; hops...); kernel)</code></p><p><strong>Keywords</strong></p><ul><li><code>kernel</code>: if missing, all orbitals blocks <code>gᵢⱼ = g[i, j]</code> between selected sites pairs (i,j) are returned when indexing <code>g[sitepairs(...)]</code>. Otherwise, <code>gᵢⱼ</code> is replaced by <code>Tr(gᵢⱼ*kernel)</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; g = HP.graphene(orbitals = 2, a0 = 1) |&gt; attach(nothing, cells = (0,0)) |&gt; greenfunction();

julia&gt; summary(g(1)[sitepairs(range = 1)])     # g(ω=1) site blocks between all sites in zero cell and all other sites at distance 1
&quot;28×4 OrbitalSliceMatrix{ComplexF64,SparseArrays.SparseMatrixCSC{ComplexF64, Int64}}&quot;

julia&gt; summary(g(1)[sitepairs(range = 1, kernel = SA[1 0; 0 -1])])    # σz spin density of the above
&quot;14×2 OrbitalSliceMatrix{ComplexF64,SparseArrays.SparseMatrixCSC{ComplexF64, Int64}}&quot;</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`diagonal`, `hopselector`, `greenfunction`, `ldos`, `densitymatrix`, `OrbitalSliceArray`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL1842-L1878">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.sites" href="#Quantica.sites"><code>Quantica.sites</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sites(lat::Lattice[, sublat])</code></pre><p>Return a collection of site positions in the unit cell of lattice <code>lat</code>. If a <code>sublat::Symbol</code> or <code>sublat::Int</code> is specified, only sites for the specified sublattice are returned.</p><pre><code class="nohighlight hljs">sites(ls::LatticeSlice)</code></pre><p>Return a collection of positions of a LatticeSlice, generally obtained by indexing a lattice <code>lat[sel...]</code> with some <code>siteselector</code> keywords <code>sel</code>. See also <code>lattice</code>.</p><p>Note: the returned collections can be of different types (vectors, generators, views...)</p><pre><code class="nohighlight hljs">sites(cell_index, site_indices)
sites(site_indices)</code></pre><p>Construct a simple selector of sites, of type <code>CellSites</code>, with given <code>site_indices</code> in a given cell at <code>cell_index</code>. Here, <code>site_indices</code> can be an index, a collection of integers or <code>:</code> (for all sites), and <code>cell_index</code> should be a collection of <code>L</code> integers, where <code>L</code> is the lattice dimension. If omitted, <code>cell_index</code> defaults to the zero-th cell <code>(0,...)</code>.</p><p><code>CellSites</code> produced with <code>sites</code> can be used to index <code>Lattice</code>s, <code>AbstractHamiltonian</code>s, <code>GreenFunction</code>s, <code>GreenSlice</code>s, <code>OrbitalSliceArray</code>s, etc. Note that selecting sites based on cell and site indices requires finding the indices beforehand, which can be done e.g. through plotting the system with <code>qplot</code>. This is lower level and potentially more fragile than using <code>siteselector</code>s, as indices are chosen freely by Quantica in an unspecified way, but it does have a smaller overhead.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sites(LatticePresets.honeycomb(), :A)
1-element view(::Vector{SVector{2, Float64}}, 1:1) with eltype SVector{2, Float64}:
 [0.0, -0.2886751345948129]</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`lattice`, `siteselector`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL226-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.siteselector" href="#Quantica.siteselector"><code>Quantica.siteselector</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">siteselector(; region = missing, sublats = missing, cells = missing)</code></pre><p>Return a <code>SiteSelector</code> object that can be used to select a finite set of sites in a lattice. Sites at position <code>r::SVector{E}</code>, belonging to a cell of index <code>n::SVector{L,Int}</code> and to a sublattice with name <code>s::Symbol</code> will be selected only if</p><pre><code class="nohighlight hljs">`region(r) &amp;&amp; s in sublats &amp;&amp; n in cells`</code></pre><p>Any missing <code>region</code>, <code>sublat</code> or <code>cells</code> will not be used to constraint the selection.</p><p><strong>Generalization</strong></p><p>While <code>sublats</code> and <code>cells</code> are usually collections of <code>Symbol</code>s and <code>SVector</code>s, respectively, they also admit other possibilities:</p><ul><li>If either <code>cells</code> or <code>sublats</code> are a single cell or sublattice, they will be treated as single-element collections</li><li>If <code>sublat</code> is a collection of <code>Integer</code>s, it will refer to sublattice numbers.</li><li>If <code>cells</code> is an <code>i::Integer</code>, it will be converted to an <code>SVector{1}</code></li><li>If <code>cells</code> is a collection, each element will be converted to an <code>SVector</code>.</li><li>If <code>cells</code> is a boolean function, <code>n in cells</code> will be the result of <code>cells(n)</code></li></ul><p><strong>Usage</strong></p><p>Although the constructor <code>siteselector(; kw...)</code> is exported, the end user does not usually need to call it directly. Instead, the keywords <code>kw</code> are input into different functions that allow filtering sites, which themselves call <code>siteselector</code> internally as needed. Some of these functions are</p><ul><li>getindex(lat::Lattice; kw...) : return a LatticeSlice with sites specified by <code>kw</code> (also <code>lat[kw...]</code>)</li><li>supercell(lat::Lattice; kw...) : returns a bounded lattice with the sites specified by <code>kw</code></li><li>onsite(...; kw...) : onsite model term to be applied to sites specified by <code>kw</code></li><li>@onsite!(...; kw...) : onsite modifier to be applied to sites specified by <code>kw</code></li></ul><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`hopselector`, `lattice`, `supercell`, `onsite`, `@onsite`, `@onsite!`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL475-L511">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.spectrum" href="#Quantica.spectrum"><code>Quantica.spectrum</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spectrum(h::AbstractHamiltonian, ϕs; solver = EigenSolvers.LinearAlgebra(), transform = missing, params...)</code></pre><p>Compute the <code>Spectrum</code> of the Bloch matrix <code>h(ϕs; params...)</code> using the specified eigensolver, with <code>transform</code> applied to the resulting eigenenergies, if not <code>missing</code>. Eigenpairs are sorted by the real part of their energy. See <code>EigenSolvers</code> for available solvers and their options.</p><pre><code class="nohighlight hljs">spectrum(h::AbstractHamiltonian; kw...)</code></pre><p>For a 0D <code>h</code>, equivalent to <code>spectrum(h, (); kw...)</code></p><pre><code class="nohighlight hljs">spectrum(m::AbstractMatrix; solver = EigenSolvers.LinearAlgebra()], transform = missing)</code></pre><p>Compute the <code>Spectrum</code> of matrix <code>m</code> using <code>solver</code> and <code>transform</code>.</p><pre><code class="nohighlight hljs">spectrum(b::Bandstructure, ϕs)</code></pre><p>Compute the <code>Spectrum</code> corresponding to slicing the bandstructure <code>b</code> at point <code>ϕs</code> of its base mesh (see <code>bands</code> for details).</p><p><strong>Indexing and destructuring</strong></p><p>Eigenenergies <code>ϵs::Tuple</code> and eigenstates <code>ψs::Matrix</code> can be extracted from a spectrum <code>sp</code> using any of the following</p><pre><code class="nohighlight hljs">ϵs, ψs = sp
ϵs = first(sp)
ϵs = energies(sp)
ψs = last(sp)
ψs = states(sp)</code></pre><p>In addition, one can extract the <code>n</code> eigenpairs closest (in real energy) to a given energy <code>ϵ₀</code> with</p><pre><code class="nohighlight hljs">ϵs, ψs = sp[1:n, around = ϵ₀]</code></pre><p>More generally, <code>sp[inds, around = ϵ₀]</code> will take the eigenpairs at position given by <code>inds</code> after sorting by increasing distance to <code>ϵ₀</code>, or the closest eigenpair in <code>inds</code> is missing. If <code>around</code> is omitted, the ordering in <code>sp</code> is used.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h = HP.graphene(t0 = 1); spectrum(h, (0,0))
Spectrum{Float64,ComplexF64} :
Energies:
2-element Vector{ComplexF64}:
 -2.9999999999999982 + 0.0im
  2.9999999999999982 + 0.0im
States:
2×2 Matrix{ComplexF64}:
 -0.707107+0.0im  0.707107+0.0im
  0.707107+0.0im  0.707107+0.0im</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`EigenSolvers`, `bands`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL1346-L1404">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.states" href="#Quantica.states"><code>Quantica.states</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">states(sp::Spectrum)</code></pre><p>Returns the eigenstates in <code>sp</code> as columns of a matrix. Equivalent to <code>last(sp)</code>.</p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`spectrum`, `bands`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL1417-L1424">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.stitch" href="#Quantica.stitch"><code>Quantica.stitch</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stitch(h::AbstractHamiltonian, (ϕ₁, ϕ₂,...))</code></pre><p>For an <code>h</code> of lattice dimension <code>L</code> and a set of <code>L</code> Bloch phases <code>ϕ = (ϕ₁, ϕ₂,...)</code>, contruct a new <code>h´::AbstractHamiltonian</code> with all Bravais vectors eliminated by stitching the lattice onto itself along the corresponding Bravais vector. Intercell hoppings along stitched directions will pick up Bloch phases <code>exp(-iϕ⋅dn)</code>, where the <code>dn</code> vectors are the cell indices of each harmonic.</p><p>If a number <code>L´</code> of phases <code>ϕᵢ</code> are <code>:</code> instead of numbers, the corresponding Bravais vectors will not be stitched, and the resulting <code>h´</code> will have a finite lattice dimension <code>L´ &lt;= L</code>.</p><pre><code class="nohighlight hljs">stitch(h::AbstractHamiltonian, wrapped_axes::SVector)</code></pre><p>Like the above with phases <code>ϕ = 0</code> along axes given by <code>wrapped_axes</code>, leaving the remaining axes unstitched. With this syntax, <code>wrapped_axes</code> should be a sorted SVector of unique integers in the range 1:L.</p><p><strong>Currying</strong></p><pre><code class="nohighlight hljs">h |&gt; stitch(x)</code></pre><p>Currying syntax equivalent to <code>stitch(h, x)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h2D = HP.graphene(); h1D = stitch(h2D, (:, 0.2))
Hamiltonian{Float64,2,1}: Hamiltonian on a 1D Lattice in 2D space
  Bloch harmonics  : 3
  Harmonic size    : 2 × 2
  Orbitals         : [1, 1]
  Element type     : scalar (ComplexF64)
  Onsites          : 0
  Hoppings         : 4
  Coordination     : 2.0

julia&gt; h2D((0.3, 0.2)) ≈ h1D(0.3)
true

julia&gt; stitch(h2D, (:, 0)) == stitch(h2D, SA[2])
true</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`@stitch`, `hamiltonian`, `supercell`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL1164-L1211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.subdiv" href="#Quantica.subdiv"><code>Quantica.subdiv</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">subdiv((x₁, x₂, ..., xₙ), (p₁, p₂, ..., pₙ₋₁))</code></pre><p>Build a vector of values between <code>x₁</code> and <code>xₙ</code> containing all <code>xᵢ</code> such that in each interval <code>[xᵢ, xᵢ₊₁]</code> there are <code>pᵢ</code> equally space values.</p><pre><code class="nohighlight hljs">subdiv((x₁, x₂, ..., xₙ), p)</code></pre><p>Same as above with all <code>pᵢ = p</code></p><pre><code class="nohighlight hljs">subdiv(x₁, x₂, p)</code></pre><p>Equivalent to <code>subdiv((x₁, x₂), p) == collect(range(x₁, x₂, length = p))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL1527-L1540">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.sublat" href="#Quantica.sublat"><code>Quantica.sublat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sublat(sites...; name::Symbol = :A)
sublat(sites::AbstractVector; name::Symbol = :A)</code></pre><p>Create a <code>Sublat{E,T}</code> that adds a sublattice, of name <code>name</code>, with sites at positions <code>sites</code> in <code>E</code> dimensional space. Sites positions can be entered as <code>Tuple</code>s or <code>SVector</code>s.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sublat((0.0, 0), (1, 1), (1, -1), name = :A)
Sublat{2,Float64} : sublattice of Float64-typed sites in 2D space
  Sites    : 3
  Name     : :A</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL121-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.supercell" href="#Quantica.supercell"><code>Quantica.supercell</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">supercell(lat::Lattice{E,L}, v::NTuple{L,Integer}...; seed = missing, kw...)
supercell(lat::Lattice{E,L}, uc::SMatrix{L,L´,Int}; seed = missing, kw...)</code></pre><p>Generate a new <code>Lattice</code> from an <code>L</code>-dimensional lattice <code>lat</code> with a larger unit cell, such that its Bravais vectors are <code>br´= br * uc</code>. Here <code>uc::SMatrix{L,L´,Int}</code> is the integer supercell matrix, with the <code>L´</code> vectors <code>v</code>s as its columns. If no <code>v</code> are given, the new lattice will have no Bravais vectors (i.e. it will be bounded, with its shape determined by keywords <code>kw...</code>). Likewise, if <code>L´ &lt; L</code>, the resulting lattice will be bounded along <code>L´ - L</code> directions, as dictated by <code>kw...</code>.</p><p>Only sites selected by <code>siteselector(; kw...)</code> will be included in the supercell (see <code>siteselector</code> for details on the available keywords <code>kw</code>). If no keyword <code>region</code> is given in <code>kw</code>, a single Bravais unit cell perpendicular to the <code>v</code> axes will be selected along the <code>L-L´</code> bounded directions.</p><pre><code class="nohighlight hljs">supercell(lattice::Lattice{E,L}, factors::Integer...; seed = missing, kw...)</code></pre><p>Call <code>supercell</code> with different scaling along each Bravais vector, so that supercell matrix <code>uc</code> is <code>Diagonal(factors)</code>. If a single <code>factor</code> is given, <code>uc = SMatrix{L,L}(factor * I)</code></p><pre><code class="nohighlight hljs">supercell(h::Hamiltonian, v...; mincoordination = 0, seed = missing, kw...)</code></pre><p>Transform the <code>Lattice</code> of <code>h</code> to have a larger unit cell, while expanding the Hamiltonian accordingly.</p><p><strong>Keywords</strong></p><ul><li><code>seed::NTuple{L,Integer}</code>: starting cell index to perform search of included sites. By default <code>seed = missing</code>, which makes search start from the zero-th cell.</li><li><code>mincoordination::Integer</code>: minimum number of nonzero hopping neighbors required for sites to be included in the supercell. Sites with less coordination will be removed recursively, until all remaining sites satisfy <code>mincoordination</code>.</li></ul><p><strong>Currying</strong></p><pre><code class="nohighlight hljs">lat_or_h |&gt; supercell(v...; kw...)</code></pre><p>Curried syntax, equivalent to <code>supercell(lat_or_h, v...; kw...)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; LatticePresets.square() |&gt; supercell((1, 1), region = r -&gt; 0 &lt; r[1] &lt; 5)
Lattice{Float64,2,1} : 1D lattice in 2D space
  Bravais vectors : [[1.0, 1.0]]
  Sublattices     : 1
    Names         : (:A,)
    Sites         : (8,) --&gt; 8 total per unit cell

julia&gt; LatticePresets.honeycomb() |&gt; supercell(3)
Lattice{Float64,2,2} : 2D lattice in 2D space
  Bravais vectors : [[1.5, 2.598076], [-1.5, 2.598076]]
  Sublattices     : 2
    Names         : (:A, :B)
    Sites         : (9, 9) --&gt; 18 total per unit cell</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`supercell`, `siteselector`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL282-L339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.transform" href="#Quantica.transform"><code>Quantica.transform</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transform(lat_or_h::Union{Lattice,AbstractHamiltonian}, f::Function)</code></pre><p>Build a new lattice or hamiltonian transforming each site positions <code>r</code> into <code>f(r)</code>.</p><p><strong>Currying</strong></p><pre><code class="nohighlight hljs">x |&gt; transform(f::Function)</code></pre><p>Curried version of <code>transform</code>, equivalent to <code>transform(f, x)</code></p><p>Note: Unexported <code>Quantica.transform!</code> is also available for in-place transforms. Use with care, as aliasing (i.e. several objects sharing the modified one) can produce unexpected results.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; LatticePresets.square() |&gt; transform(r -&gt; 3r)
Lattice{Float64,2,2} : 2D lattice in 2D space
  Bravais vectors : [[3.0, 0.0], [0.0, 3.0]]
  Sublattices     : 1
    Names         : (:A,)
    Sites         : (1,) --&gt; 1 total per unit cell</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`translate`, `reverse`, `reverse!`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL363-L391">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.translate" href="#Quantica.translate"><code>Quantica.translate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">translate(lat::Lattice, δr)</code></pre><p>Build a new lattice translating each site positions from <code>r</code> to <code>r + δr</code>, where <code>δr</code> can be a <code>NTuple</code> or an <code>SVector</code> in embedding space.</p><p><strong>Currying</strong></p><pre><code class="nohighlight hljs">x |&gt; translate(δr)</code></pre><p>Curried version of <code>translate</code>, equivalent to <code>translate(x, δr)</code></p><p>Note: Unexported <code>Quantica.translate!</code> is also available for in-place translations. Use with care, as aliasing (i.e. several objects sharing the modified one) can produce unexpected results.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; LatticePresets.square() |&gt; translate((3,3)) |&gt; sites
1-element Vector{SVector{2, Float64}}:
 [3.0, 3.0]
</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`transform`, `reverse`, `reverse!`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL394-L422">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.transmission" href="#Quantica.transmission"><code>Quantica.transmission</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transmission(gs::GreenSlice)</code></pre><p>Given a slice <code>gs = g[i::Integer, j::Integer]</code> of a <code>g::GreenFunction</code>, build a partially evaluated object <code>T::Transmission</code> representing the normal transmission probability <code>Tᵢⱼ(ω)</code> from contact <code>j</code> to <code>i</code> at energy <code>ω</code>. It can be written as <span>$Tᵢⱼ = Tr{gʳΓⁱgᵃΓʲ}$</span>. Here <code>gʳ = g(ω)</code> and <code>gᵃ = (gʳ)&#39; = g(ω&#39;)</code> are the retarded and advanced Green function of the system, and <code>Γⁱ = im * (Σⁱ - Σⁱ&#39;)</code> is the decay rate at contact <code>i</code></p><p><strong>Full evaluation</strong></p><pre><code class="nohighlight hljs">T(ω; params...)</code></pre><p>Compute the transmission <code>Tᵢⱼ(ω)</code> at a given <code>ω</code> and for the specified <code>params</code> of <code>g</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # A central system g0 with two 1D leads and transparent contacts

julia&gt; glead = LP.square() |&gt; hamiltonian(hopping(1)) |&gt; supercell((1,0), region = r-&gt;-2&lt;r[2]&lt;2) |&gt; greenfunction(GS.Schur(boundary = 0));

julia&gt; g0 = LP.square() |&gt; hamiltonian(hopping(1)) |&gt; supercell(region = r-&gt;-2&lt;r[2]&lt;2 &amp;&amp; r[1]≈0) |&gt; attach(glead, reverse = true) |&gt; attach(glead) |&gt; greenfunction;

julia&gt; T = transmission(g0[2, 1])
Transmission: total transmission between two different contacts
  From contact  : 1
  To contact    : 2

julia&gt; T(0.2) ≈ 3   # The difference from 3 is due to the automatic `im*sqrt(eps(Float64))` added to `ω`
false

julia&gt; T(0.2 + 1e-10im) ≈ 3
true</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`greenfunction`, `conductance`, `ldos`, `current`, `josephson`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL2071-L2110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.unflat" href="#Quantica.unflat"><code>Quantica.unflat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unflat(dn)</code></pre><p>Construct an <code>u::Unflat</code> object wrapping some indices <code>dn</code>. This object is meant to be used to index into a <code>h::AbstractHamiltonian</code> as <code>h[u]</code>, which returns an non-flattened version of the Bloch harmonic <code>h[dn]</code>. Each element in the matrix <code>h[u]</code> is an <code>SMatrix</code> block representing onsite or hoppings between whole sites, in contrast to <code>h[dn]</code> where they are scalars representing single orbitals. This is only relevant for multi-orbital Hamiltonians <code>h</code>.</p><pre><code class="nohighlight hljs">unflat()</code></pre><p>Equivalent to <code>unflat(())</code></p><pre><code class="nohighlight hljs">unflat(a::OrbitalSliceArray)</code></pre><p>Convert an <code>OrbitalSliceArray</code> into an array of views, where each view corresponds to a block for whole sites (see also <code>siteindexdict</code>).</p><pre><code class="nohighlight hljs">unflat(f, a::OrbitalSliceArray)</code></pre><p>Like above, but apply <code>f</code> to each <code>view</code> block. Useful e.g. to convert views into StaticArrays with <code>f == SMatrix{N,N}</code>, see examples.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; h = HP.graphene(orbitals = 2); h[unflat(0,0)]
2×2 SparseArrays.SparseMatrixCSC{SMatrix{2, 2, ComplexF64, 4}, Int64} with 2 stored entries:
                     ⋅                       [2.7+0.0im 0.0+0.0im; 0.0+0.0im 2.7+0.0im]
 [2.7+0.0im 0.0+0.0im; 0.0+0.0im 2.7+0.0im]                      ⋅

 julia&gt; hmat = h[cells = (SA[0,0], SA[1,1])]
8×8 OrbitalSliceMatrix{ComplexF64,SparseArrays.SparseMatrixCSC{ComplexF64, Int64}}:
 0.0+0.0im  0.0+0.0im  2.7+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  2.7+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 2.7+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  2.7+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  2.7+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  2.7+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  2.7+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  2.7+0.0im  0.0+0.0im  0.0+0.0im

julia&gt; unflat(SMatrix{2,2}, hmat)
4×4 Matrix{SMatrix{2, 2, ComplexF64, 4}}:
 [0.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]  [2.7+0.0im 0.0+0.0im; 0.0+0.0im 2.7+0.0im]  [0.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]  [0.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]
 [2.7+0.0im 0.0+0.0im; 0.0+0.0im 2.7+0.0im]  [0.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]  [0.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]  [0.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]
 [0.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]  [0.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]  [0.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]  [2.7+0.0im 0.0+0.0im; 0.0+0.0im 2.7+0.0im]
 [0.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]  [0.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]  [2.7+0.0im 0.0+0.0im; 0.0+0.0im 2.7+0.0im]  [0.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`flat`, `OrbitalSliceArray`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL1247-L1301">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.σ" href="#Quantica.σ"><code>Quantica.σ</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Quantica.σ(n::Int)</code></pre><p>Return <code>n</code>-th Pauli matrix as a <code>SMatrix{2,2,ComplexF64}</code>, where <code>n = 0,1,2,3</code>.</p><pre><code class="nohighlight hljs">Quantica.σ(name::Symbol)</code></pre><p>Return Pauli matrix by name. Valid names are <code>:I</code>, <code>:x</code>, <code>:y</code>, <code>:z</code> for <code>n = 0,1,2,3</code>, respectively. Can also use <code>σ.name</code>. If <code>name</code> is a juxtaposition of two of the above (e.g. <code>σ.xy</code>), the result will be the direct product of the two matrices (i.e. <code>σ(:x, :y)</code>, see below).</p><pre><code class="nohighlight hljs">Quantica.σ((θ, ϕ)::Tuple)</code></pre><p>Return <code>σ(1)*sin(θ)*cos(ϕ) + σ(2)*sin(θ)*sin(ϕ) + σ(3)*cos(θ)</code>, i.e. the Pauli matrix in the Bloch sphere.</p><pre><code class="nohighlight hljs">Quantica.σ(n1, n2, ...)</code></pre><p>Return the direct product <code>σ(n1)⊗σ(n2)⊗...</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Quantica: σ

julia&gt; σ.xz
4×4 SMatrix{4, 4, ComplexF64, 16} with indices SOneTo(4)×SOneTo(4):
 0.0+0.0im   0.0+0.0im  1.0+0.0im   0.0+0.0im
 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -1.0+0.0im
 1.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im
 0.0+0.0im  -1.0+0.0im  0.0+0.0im  -0.0+0.0im

julia&gt; σ((π/2, π/4)) ≈ cos(π/4)*σ.x + sin(π/4)*σ.y
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL2845-L2881">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.@hopping" href="#Quantica.@hopping"><code>Quantica.@hopping</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@hopping((; params...) -&gt; t(; params...); hops...)
@hopping((r, dr; params...) -&gt; t(r; params...); hops...)</code></pre><p>Build a <code>ParametricModel</code> representing a uniform or a position-dependent hopping amplitude, respectively, on hops selected by <code>hopselector(; hops...)</code> (see <code>hopselector</code> for details).</p><p>Hops from a site at position <code>r₁</code> to another at <code>r₂</code> are described using the hop center <code>r = (r₁ + r₂)/2</code> and the hop vector <code>dr = r₂ - r₁</code>. Hopping amplitudes <code>t</code> can be a <code>Number</code> (for hops between single-orbital sites), a <code>UniformScaling</code> (e.g. <code>2I</code>) or an <code>AbstractMatrix</code> (use <code>SMatrix</code> for performance) of dimensions matching the number of site orbitals in the selected sites. Parametric models may be applied to a lattice <code>lat</code> to produce a <code>ParametricHamiltonian</code> with <code>hamiltonian(lat, model; ...)</code>, see <code>hamiltonian</code>. Position dependent models are forced to preserve the periodicity of the lattice.</p><p>The difference between regular and parametric tight-binding models (see <code>onsite</code> and <code>hopping</code>) is that parametric models may depend on arbitrary parameters, specified by the <code>params</code> keyword arguments. These are inherited by <code>h::ParametricHamiltonian</code>, which can then be evaluated very efficiently for different parameter values by callling <code>h(; params...)</code>, to obtain a regular <code>Hamiltonian</code> without reconstructing it from scratch.</p><pre><code class="nohighlight hljs">@hopping((ω; params...) -&gt; Σᵢⱼ(ω; params...); hops...)
@hopping((ω, r, dr; params...) -&gt; Σᵢⱼ(ω, r, dr; params...); hops...)</code></pre><p>Special form of a parametric hopping amplitude meant to model a self-energy (see <code>attach</code>).</p><pre><code class="nohighlight hljs">@hopping((i, j; params...) --&gt; ...; sites...)
@hopping((ω, i, j; params...) --&gt; ...; sites...)</code></pre><p>The <code>--&gt;</code> syntax allows to treat the arguments <code>i, j</code> as a site indices, instead of a positions. Here <code>i</code> is the destination (row) and <code>j</code> the source (column) site. In fact, the type of <code>i</code> and <code>j</code> is <code>CellSitePos</code>, so they can be used to index <code>OrbitalSliceArray</code>s (see doctrings for details). The functions <code>pos(i)</code>, <code>cell(i)</code> and <code>ind(i)</code> yield the position, cell and site index of the site. This syntax is useful to implement models that depend on observables (in the form of <code>OrbitalSliceArray</code>s), like in self-consistent mean field calculations.</p><p><strong>Model algebra</strong></p><p>Parametric models can be combined using <code>+</code>, <code>-</code> and <code>*</code>, or conjugated with <code>&#39;</code>, e.g. <code>@onsite((; o=1) -&gt; o) - 2 * hopping(1)&#39;</code>. The combined parametric models can share parameters.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = @hopping((r, dr; t = 1, A = Returns(SA[0,0])) -&gt; t * cis(-dr&#39; * A(r)))
ParametricModel: model with 1 term
  ParametricHoppingTerm{ParametricFunction{2}}
    Region            : any
    Sublattice pairs  : any
    Cell distances    : any
    Hopping range     : Neighbors(1)
    Reverse hops      : false
    Coefficient       : 1
    Argument type     : spatial
    Parameters        : [:t, :A]

julia&gt; LP.honeycomb() |&gt; supercell(2) |&gt; hamiltonian(model)
ParametricHamiltonian{Float64,2,2}: Parametric Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5
  Harmonic size    : 8 × 8
  Orbitals         : [1, 1]
  Element type     : scalar (ComplexF64)
  Onsites          : 0
  Hoppings         : 24
  Coordination     : 3.0
  Parameters       : [:A, :t]</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`onsite`, `hopping`, `@onsite`, `@onsite!`, `@hopping!`, `attach`, `hamiltonian`, `OrbitalSliceArray`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL933-L1004">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.@hopping!" href="#Quantica.@hopping!"><code>Quantica.@hopping!</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@hopping!((t; params...) -&gt; t´(t; params...); hops...)
@hopping!((t, r, dr; params...) -&gt; t´(t, r, dr; params...); hops...)</code></pre><p>Build a uniform or position-dependent hopping term modifier, respectively, acting on hops selected by <code>hopselector(; hops...)</code> (see <code>hopselector</code> for details).</p><p>Hops from a site at position <code>r₁</code> to another at <code>r₂</code> are described using the hop center <code>r = (r₁ + r₂)/2</code> and the hop vector <code>dr = r₂ - r₁</code>. The original hopping amplitude is <code>t</code>, and the modified hopping is <code>t´</code>, which is a function of <code>t</code> and possibly <code>r, dr</code>. It may optionally also depend on parameters, enconded in <code>params</code>.</p><p>Modifiers are meant to be applied to an <code>h:AbstractHamiltonian</code> to obtain a <code>ParametricHamiltonian</code> (with <code>hamiltonian(h, modifiers...)</code> or <code>hamiltonian(lat, model, modifiers...)</code>, see <code>hamiltonian</code>). Modifiers will affect only pre-existing model terms. In particular, if no onsite model has been applied to a specific site, its onsite potential will be zero, and will not be modified by any <code>@onsite!</code> modifier. Conversely, if an onsite model has been applied, <code>@onsite!</code> may modify the onsite potential even if it is zero. The same applies to <code>@hopping!</code>.</p><pre><code class="nohighlight hljs">@hopping!((t, i, j; params...) --&gt; ...; sites...)</code></pre><p>The <code>--&gt;</code> syntax allows to treat the arguments <code>i, j</code> as a site indices, instead of a positions. Here <code>i</code> is the destination (row) and <code>j</code> the source (column) site. In fact, the type of <code>i</code> and <code>j</code> is <code>CellSitePos</code>, so they can be used to index <code>OrbitalSliceArray</code>s (see doctrings for details). The functions <code>pos(i)</code>, <code>cell(i)</code> and <code>ind(i)</code> yield the position, cell and site index of the site. This syntax is useful to implement models that depend on observables (in the form of <code>OrbitalSliceArray</code>s), like in self-consistent mean field calculations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = hopping(1); peierls = @hopping!((t, r, dr; A = r -&gt; SA[0,0]) -&gt; t * cis(-dr&#39; * A(r)))
HoppingModifier{ParametricFunction{3}}:
  Region            : any
  Sublattice pairs  : any
  Cell distances    : any
  Hopping range     : Inf
  Reverse hops      : false
  Argument type     : spatial
  Parameters        : [:A]

julia&gt; LP.honeycomb() |&gt; hamiltonian(model) |&gt; supercell(10) |&gt; hamiltonian(peierls)
ParametricHamiltonian{Float64,2,2}: Parametric Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5
  Harmonic size    : 200 × 200
  Orbitals         : [1, 1]
  Element type     : scalar (ComplexF64)
  Onsites          : 0
  Hoppings         : 600
  Coordination     : 3.0
  Parameters       : [:A]</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`onsite`, `hopping`, `@onsite`, `@hopping`, `@onsite!`, `hamiltonian`, `OrbitalSliceArray`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL1062-L1118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.@onsite" href="#Quantica.@onsite"><code>Quantica.@onsite</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@onsite((; params...) -&gt; o(; params...); sites...)
@onsite((r; params...) -&gt; o(r; params...); sites...)</code></pre><p>Build a <code>ParametricModel</code> representing a uniform or a position-dependent onsite potential, respectively, on sites selected by <code>siteselector(; sites...)</code> (see <code>siteselector</code> for details).</p><p>Site positions are <code>r::SVector{E}</code>, where <code>E</code> is the embedding dimension of the lattice. The onsite potential <code>o</code> can be a <code>Number</code> (for single-orbital sites), a <code>UniformScaling</code> (e.g. <code>2I</code>) or an <code>AbstractMatrix</code> (use <code>SMatrix</code> for performance) of dimensions matching the number of orbitals in the selected sites. Parametric models may be applied to a lattice <code>lat</code> to produce a <code>ParametricHamiltonian</code> with <code>hamiltonian(lat, model; ...)</code>, see <code>hamiltonian</code>. Position dependent models are forced to preserve the periodicity of the lattice.</p><p>The difference between regular and parametric tight-binding models (see <code>onsite</code> and <code>hopping</code>) is that parametric models may depend on arbitrary parameters, specified by the <code>params</code> keyword arguments. These are inherited by <code>h::ParametricHamiltonian</code>, which can then be evaluated very efficiently for different parameter values by callling <code>h(; params...)</code>, to obtain a regular <code>Hamiltonian</code> without reconstructing it from scratch.</p><pre><code class="nohighlight hljs">@onsite((ω; params...) -&gt; Σᵢᵢ(ω; params...); sites...)
@onsite((ω, r; params...) -&gt; Σᵢᵢ(ω, r; params...); sites...)</code></pre><p>Special form of a parametric onsite potential meant to model a self-energy (see <code>attach</code>).</p><pre><code class="nohighlight hljs">@onsite((i; params...) --&gt; ...; sites...)
@onsite((ω, i; params...) --&gt; ...; sites...)</code></pre><p>The <code>--&gt;</code> syntax allows to treat the argument <code>i</code> as a site index, instead of a position. In fact, the type of <code>i</code> is <code>CellSitePos</code>, so they can be used to index <code>OrbitalSliceArray</code>s (see doctrings for details). The functions <code>pos(i)</code>, <code>cell(i)</code> and <code>ind(i)</code> yield the position, cell and site index of the site. This syntax is useful to implement models that depend on observables (in the form of <code>OrbitalSliceArray</code>s), like in self-consistent mean field calculations.</p><p><strong>Model algebra</strong></p><p>Parametric models can be combined using <code>+</code>, <code>-</code> and <code>*</code>, or conjugated with <code>&#39;</code>, e.g. <code>@onsite((; o=1) -&gt; o) - 2 * hopping(1)&#39;</code>. The combined parametric models can share parameters.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = @onsite((r; dμ = 0) -&gt; (r[1] + dμ) * I; sublats = :A) + @onsite((; dμ = 0) -&gt; - dμ * I; sublats = :B)
ParametricModel: model with 2 terms
  ParametricOnsiteTerm{ParametricFunction{1}}
    Region            : any
    Sublattices       : A
    Cells             : any
    Coefficient       : 1
    Argument type     : spatial
    Parameters        : [:dμ]
  ParametricOnsiteTerm{ParametricFunction{0}}
    Region            : any
    Sublattices       : B
    Cells             : any
    Coefficient       : 1
    Argument type     : spatial
    Parameters        : [:dμ]

julia&gt; LP.honeycomb() |&gt; supercell(2) |&gt; hamiltonian(model, orbitals = 2)
ParametricHamiltonian{Float64,2,2}: Parametric Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 1
  Harmonic size    : 8 × 8
  Orbitals         : [2, 2]
  Element type     : 2 × 2 blocks (ComplexF64)
  Onsites          : 8
  Hoppings         : 0
  Coordination     : 0.0
  Parameters       : [:dμ]</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`onsite`, `hopping`, `@hopping`, `@onsite!`, `@hopping!`, `attach`, `hamiltonian`, `OrbitalSliceArray`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL854-L930">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.@onsite!" href="#Quantica.@onsite!"><code>Quantica.@onsite!</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@onsite!((o; params...) -&gt; o´(o; params...); sites...)
@onsite!((o, r; params...) -&gt; o´(o, r; params...); sites...)</code></pre><p>Build a uniform or position-dependent onsite term modifier, respectively, acting on sites selected by <code>siteselector(; sites...)</code> (see <code>siteselector</code> for details).</p><p>Site positions are <code>r::SVector{E}</code>, where <code>E</code> is the embedding dimension of the lattice. The original onsite potential is <code>o</code>, and the modified potential is <code>o´</code>, which is a function of <code>o</code> and possibly <code>r</code>. It may optionally also depend on parameters, enconded in <code>params</code>.</p><p>Modifiers are meant to be applied to an <code>h:AbstractHamiltonian</code> to obtain a <code>ParametricHamiltonian</code> (with <code>hamiltonian(h, modifiers...)</code> or <code>hamiltonian(lat, model, modifiers...)</code>, see <code>hamiltonian</code>). Modifiers will affect only pre-existing model terms. In particular, if no onsite model has been applied to a specific site, its onsite potential will be zero, and will not be modified by any <code>@onsite!</code> modifier. Conversely, if an onsite model has been applied, <code>@onsite!</code> may modify the onsite potential even if it is zero. The same applies to <code>@hopping!</code>.</p><pre><code class="nohighlight hljs">@onsite((o, i; params...) --&gt; ...; sites...)</code></pre><p>The <code>--&gt;</code> syntax allows to treat the argument <code>i</code> as a site index, instead of a position. In fact, the type of <code>i</code> is <code>CellSitePos</code>, so they can be used to index <code>OrbitalSliceArray</code>s (see doctrings for details). The functions <code>pos(i)</code>, <code>cell(i)</code> and <code>ind(i)</code> yield the position, cell and site index of the site. This syntax is useful to implement models that depend on observables (in the form of <code>OrbitalSliceArray</code>s), like in self-consistent mean field calculations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = onsite(0); disorder = @onsite!((o; W = 0) -&gt; o + W * rand())
OnsiteModifier{ParametricFunction{1}}:
  Region            : any
  Sublattices       : any
  Cells             : any
  Argument type     : spatial
  Parameters        : [:W]

julia&gt; LP.honeycomb() |&gt; hamiltonian(model) |&gt; supercell(10) |&gt; hamiltonian(disorder)
ParametricHamiltonian{Float64,2,2}: Parametric Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 1
  Harmonic size    : 200 × 200
  Orbitals         : [1, 1]
  Element type     : scalar (ComplexF64)
  Onsites          : 200
  Hoppings         : 0
  Coordination     : 0.0
  Parameters       : [:W]</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`onsite`, `hopping`, `@onsite`, `@hopping`, `@hopping!`, `hamiltonian`, `OrbitalSliceArray`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL1007-L1059">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Quantica.@stitch" href="#Quantica.@stitch"><code>Quantica.@stitch</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@stitch(h, phases_or_axes, param_name)</code></pre><p>Equivalent to <code>stitch(h, phases_or_axes)</code>, but returning an <code>n</code>-dimensional <code>h´::ParametricHamiltonian</code> with an additional parameter called <code>param_name</code>. When calling <code>h´(...; param_name = (ϕ₁,...,ϕₙ), params...)</code>, Bloch phases <code>(ϕ₁,...,ϕₙ)</code> are applied along stitched directions (in addition to the ones specified in <code>phases_or_axes</code>, if any). <code>param_name</code> can also take any <code>AbstractArray</code>, or a <code>Number</code> if <code>n=1</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h2D = HP.graphene() |&gt; supercell(2); h1D = stitch(h2D, (:, 0.3)); h1D´ = @stitch(h2D, SA[2], ϕ)
ParametricHamiltonian{Float64,2,1}: Parametric Hamiltonian on a 1D Lattice in 2D space
  Bloch harmonics  : 3
  Harmonic size    : 8 × 8
  Orbitals         : [1, 1]
  Element type     : scalar (ComplexF64)
  Onsites          : 0
  Hoppings         : 24
  Coordination     : 3.0
  Parameters       : [:ϕ]

julia&gt; h1D´(0.5; ϕ = 0.3) ≈ h1D(0.5)
true</code></pre><p><strong>See also</strong></p><pre><code class="nohighlight hljs">`stitch`, `hamiltonian`, `supercell`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/e89e15692352e20991d324721e60d79314454725/src/docstrings.jl#LL1214-L1244">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 1 October 2025 14:34">Wednesday 1 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
