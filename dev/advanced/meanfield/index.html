<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Self-consistent mean fields · Quantica.jl</title><meta name="title" content="Self-consistent mean fields · Quantica.jl"/><meta property="og:title" content="Self-consistent mean fields · Quantica.jl"/><meta property="twitter:title" content="Self-consistent mean fields · Quantica.jl"/><meta name="description" content="Documentation for Quantica.jl."/><meta property="og:description" content="Documentation for Quantica.jl."/><meta property="twitter:description" content="Documentation for Quantica.jl."/><meta property="og:url" content="https://pablosanjose.github.io/Quantica.jl/advanced/meanfield/"/><meta property="twitter:url" content="https://pablosanjose.github.io/Quantica.jl/advanced/meanfield/"/><link rel="canonical" href="https://pablosanjose.github.io/Quantica.jl/advanced/meanfield/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/><link href="../../assets/QUDYMA_favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Quantica.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Quantica.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../../tutorial/tutorial/">Welcome</a></li><li><a class="tocitem" href="../../tutorial/glossary/">Glossary</a></li><li><a class="tocitem" href="../../tutorial/lattices/">Lattices</a></li><li><a class="tocitem" href="../../tutorial/models/">Models</a></li><li><a class="tocitem" href="../../tutorial/hamiltonians/">Hamiltonians</a></li><li><a class="tocitem" href="../../tutorial/bandstructures/">Bandstructures</a></li><li><a class="tocitem" href="../../tutorial/greenfunctions/">GreenFunctions</a></li><li><a class="tocitem" href="../../tutorial/observables/">Observables</a></li></ul></li><li><span class="tocitem">Advanced</span><ul><li><a class="tocitem" href="../nonspatial/">Non-spatial models</a></li><li><a class="tocitem" href="../serializers/">Serializers</a></li><li class="is-active"><a class="tocitem" href>Self-consistent mean fields</a><ul class="internal"><li><a class="tocitem" href="#Using-an-external-fixed-point-solver"><span>Using an external fixed-point solver</span></a></li><li><a class="tocitem" href="#Using-Serializers-with-fixed-point-solvers"><span>Using Serializers with fixed-point solvers</span></a></li><li><a class="tocitem" href="#GreenSolvers-without-support-for-ParametricHamiltonians"><span>GreenSolvers without support for ParametricHamiltonians</span></a></li></ul></li><li><a class="tocitem" href="../wannier90/">Wannier90 imports</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Advanced</a></li><li class="is-active"><a href>Self-consistent mean fields</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Self-consistent mean fields</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/pablosanjose/Quantica.jl/blob/master/docs/src/advanced/meanfield.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Self-consistent-mean-field-problems"><a class="docs-heading-anchor" href="#Self-consistent-mean-field-problems">Self-consistent mean-field problems</a><a id="Self-consistent-mean-field-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Self-consistent-mean-field-problems" title="Permalink"></a></h1><p>Here we show how to solve interacting-electron problems in Quantica, approximated at the mean field level. A mean field is a collection of onsite and hopping terms that are added to a given <code>h::AbstractHamiltonian</code>, that depend on the density matrix <code>ρ</code>. Since <code>ρ</code> itself depends on <code>h</code>, this defines a self-consistent problem.</p><p>If the mean field solution is dubbed <code>Φ</code>, the problem consists in finding a fixed point solution to the function <code>Φ = M(Φ)</code> for a certain function <code>M</code> that takes <code>Φ</code>, computes <code>h</code> with the added mean field onsite and hopping terms, computes the density matrix, and from that computes the new mean field <code>Φ</code>. To attack this problem we will employ non-spatial models and a new <code>meanfield</code> constructor.</p><p>Schematically the process is as follows:</p><ul><li>We start from an <code>AbstractHamiltonian</code> that includes a non-interacting model <code>model_0</code> and non-spatial model <code>model_1 + model_2</code> with a mean field parameter, e.g. <code>Φ</code>,</li></ul><pre><code class="language-julia hljs">julia&gt; model_0 = hopping(1); # a possible non-interacting model

julia&gt; model_1 = @onsite((i; Φ = zerofield) --&gt; Φ[i]);       # Onsite Hartree-Fock

julia&gt; model_2 = @hopping((i, j; Φ = zerofield) -&gt; Φ[i, j]); # Non-local Fock

julia&gt; h = lat |&gt; hamiltonian(model_0 + model_1 + model_2)</code></pre><p>Here <code>model_1</code> corresponds to Hartree and onsite-Fock mean field terms, while <code>model_2</code> corresponds to inter-site Fock terms. The default value <code>Φ = zerofield</code> is an singleton object that represents no interactions, so <code>model_1</code> and <code>model_2</code> vanish by default.</p><ul><li><p>We build the <code>GreenFunction</code> of <code>h</code> with <code>g = greenfunction(h, solver; kw...)</code> using the <code>GreenSolver</code> of choice</p></li><li><p>We construct a <code>M::MeanField</code> object using <code>M = meanfield(g; potential = pot, other_options...)</code></p><p>Here <code>pot(r)</code> is the charge-charge interaction potential between electrons. We can also specify <code>hopselector</code> directives to define which sites interacts, adding e.g. <code>selector = (; range = 2)</code> to <code>other_options</code>, to make sites at distance <code>2</code> interacting. See <code>meanfield</code> docstring for further details.</p></li><li><p>We evaluate this <code>M</code> with <code>Φ0 = M(µ, kBT; params...)</code>.</p><p>This computes the density matrix at specific chemical potential <code>µ</code> and temperature <code>kBT</code>, and for specific parameters of <code>h</code> (possibly including <code>Φ</code>). Then it computes the appropriate Hartree and Fock terms, and stores them in the returned <code>Φ0::OrbitalSliceMatrix</code>, where <code>Φ0ᵢⱼ = δᵢⱼ hartreeᵢ + fockᵢⱼ</code>. In normal systems, these terms read</p><p><span>$\text{hartree}_i = Q \sum_k v_H(r_i-r_k) \text{tr}(\rho_{kk}Q)$</span></p><p><span>$\text{fock}_{ij}  = -v_F(r_i-r_j) Q \rho_{ij} Q$</span></p><p>where <code>v_H</code> and <code>v_F</code> are Hartree and Fock charge-charge interaction potentials (by default equal to <code>pot</code>), and the charge operator is <code>Q</code> (equal to the identity by default, but can be changed to implement e.g. spin-spin interactions).</p><p>When computing <code>Φ0</code> we don&#39;t specify <code>Φ</code> in <code>params</code>, so that <code>Φ0</code> is evaluated using the non-interacting model, hence its name.</p></li><li><p>The self-consistent condition can be tackled naively by iteration-until-convergence,</p></li></ul><pre><code class="language-julia hljs">Φ0 = M(µ, kBT; params...)
Φ1 = M(µ, KBT; Φ = Φ0, params...)
Φ2 = M(µ, KBT; Φ = Φ1, params...)
...</code></pre><p>A converged solution <code>Φ</code>, if found, should satisfy the fixed-point condition</p><pre><code class="nohighlight hljs">Φ_sol ≈ M(µ, KBT; Φ = Φ_sol, params...)</code></pre><p>Then, the self-consistent Hamiltonian is given by <code>h(; Φ = Φ_sol, params...)</code>.</p><p>The key problem is to actually find the fixed point of the <code>M</code> function. The naive iteration above is not optimal, and often does not converge. To do a better job we should use a dedicated fixed-point solver.</p><div class="admonition is-info" id="Superconducting-systems-8cfbbb60bd01f7ab"><header class="admonition-header">Superconducting systems<a class="admonition-anchor" href="#Superconducting-systems-8cfbbb60bd01f7ab" title="Permalink"></a></header><div class="admonition-body"><p>Superconducting (Nambu) Hamiltonians obey the same equations for the Hartree and Fock mean fields, with a proper definition of <code>Q</code>, and an extra <code>1/2</code> coefficient in the Hartree trace, see the <code>meanfield</code> doctring.</p></div></div><div class="admonition is-info" id="Interactions-given-in-the-form-of-a-TightbindingModel-3056578f04b7ce43"><header class="admonition-header">Interactions given in the form of a TightbindingModel<a class="admonition-anchor" href="#Interactions-given-in-the-form-of-a-TightbindingModel-3056578f04b7ce43" title="Permalink"></a></header><div class="admonition-body"><p>As explained in the <code>meanfield</code> docstring, we can also provide the interaction potential, both the <code>hartree</code> and the <code>fock</code> parts, as a non-parametric model, using the <code>onsite</code> and <code>hopping</code> functionality.</p></div></div><h2 id="Using-an-external-fixed-point-solver"><a class="docs-heading-anchor" href="#Using-an-external-fixed-point-solver">Using an external fixed-point solver</a><a id="Using-an-external-fixed-point-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Using-an-external-fixed-point-solver" title="Permalink"></a></h2><p>We now show how to approach such a fixed-point problem. We will employ an external library to solve generic fixed-point problems, and show how to make it work with Quantica <code>MeanField</code> objects efficiently. Many generic fixed-point solver backends exist. Here we use the SIAMFANLEquations.jl package. It provides a simple utility <code>aasol(f, x0)</code> that computes the solution of <code>f(x) = x</code> with initial condition <code>x0</code> using Anderson acceleration. This is an example of how it works to compute the fixed point of function <code>f(x) = 1 + atan(x)</code></p><pre><code class="language-julia hljs">julia&gt; using SIAMFANLEquations

julia&gt; f!(x, x0) = (x .= 1 .+ atan.(x0))

julia&gt; m = 3; x0 =  rand(3); vstore = rand(3, 3m+3);  # order m, initial condition x0, and preallocated space vstore

julia&gt; aasol(f!, x0, m, vstore).solution
3-element Vector{Float64}:
 2.132267725272934
 2.132267725272908
 2.132267725284556</code></pre><p>The package requires as input an in-place version <code>f!</code> of the function <code>f</code>, and the preallocation of some storage space vstore (see the <code>aasol</code> documentation). The package, as <a href="https://docs.sciml.ai/NonlinearSolve/stable/solvers/fixed_point_solvers/">a few others</a>, also requires the variable <code>x</code> and the initial condition <code>x0</code> to be an <code>AbstractArray</code> (or a scalar, but we need the former for our use case), hence the broadcast dots above. In our case we will therefore need to translate back and forth from an <code>Φ::OrbitalSliceMatrix</code> to a real vector <code>x</code> to pass it to <code>aasol</code>. This translation is achieved using Quantica&#39;s <code>serialize</code>/<code>deserialize</code> funcionality.</p><h2 id="Using-Serializers-with-fixed-point-solvers"><a class="docs-heading-anchor" href="#Using-Serializers-with-fixed-point-solvers">Using Serializers with fixed-point solvers</a><a id="Using-Serializers-with-fixed-point-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Serializers-with-fixed-point-solvers" title="Permalink"></a></h2><p>With the serializer functionality we can build a version of the fixed-point function <code>f</code> that operates on real vectors. Let&#39;s take a 1D Hamiltonian with a sawtooth potential, and build a Hartree mean field (note the <code>fock = nothing</code> keyword)</p><pre><code class="language-julia hljs">julia&gt; using SIAMFANLEquations

julia&gt; h = LP.linear() |&gt; supercell(4) |&gt; onsite(r-&gt;r[1]) - hopping(1) + @onsite((i; phi = zerofield) --&gt; phi[i]);

julia&gt; M = meanfield(greenfunction(h); onsite = 1, selector = (; range = 0), fock = nothing)
MeanField{ComplexF64} : builder of Hartree-Fock-Bogoliubov mean fields
  Charge type      : scalar (ComplexF64)
  Hartree pairs    : 4
  Mean field pairs : 4
  Nambu            : false

julia&gt; Φ0 = M(0.0, 0.0);

julia&gt; function f!(x, x0, (M, Φ0))
        Φ = M(0.0, 0.0; phi = deserialize(Φ0, x0))
        copy!(x, serialize(Φ))
        return x
    end;</code></pre><p>Then we can proceed as in the <code>f(x) = 1 + atan(x)</code> example</p><pre><code class="language-julia hljs">julia&gt; m = 2; x0 = serialize(Φ0); vstore = rand(length(x0), 3m+3);  # order m, initial condition x0, and preallocated space vstore

julia&gt; x = aasol(f!, x0, m, vstore; pdata = (M, Φ0)).solution
4-element Vector{ComplexF64}:
  0.5658185030962436 + 0.0im
   0.306216109313951 + 0.0im
 0.06696362342872919 + 0.0im
 0.06100176416107613 + 0.0im

julia&gt; h´ = h(; phi = deserialize(Φ0, x))
Hamiltonian{Float64,1,1}: Hamiltonian on a 1D Lattice in 1D space
  Bloch harmonics  : 3
  Harmonic size    : 4 × 4
  Orbitals         : [1]
  Element type     : scalar (ComplexF64)
  Onsites          : 4
  Hoppings         : 8
  Coordination     : 2.0

julia&gt; h´[()]
4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 10 stored entries:
 0.565819+0.0im     -1.0+0.0im          ⋅            ⋅
     -1.0+0.0im  1.30622+0.0im     -1.0+0.0im        ⋅
          ⋅         -1.0+0.0im  2.06696+0.0im   -1.0+0.0im
          ⋅              ⋅         -1.0+0.0im  3.061+0.0im</code></pre><p>Note that the content of <code>pdata</code> is passed by <code>aasol</code> as a third argument to <code>f!</code>. We use this to pass the serializer <code>s</code> and <code>U</code> parameter to use.</p><div class="admonition is-info" id="Bring-your-own-fixed-point-solver!-f4f3d02cffc181f"><header class="admonition-header">Bring your own fixed-point solver!<a class="admonition-anchor" href="#Bring-your-own-fixed-point-solver!-f4f3d02cffc181f" title="Permalink"></a></header><div class="admonition-body"><p>Note that fixed-point calculations can be tricky, and the search algorithm can have a huge impact in convergence (if the problem converges at all!). For this reason, Quantica.jl does not provide built-in fixed-point routines, only the functionality to write functions such as <code>f</code> above. Numerous packages exist for fixed-point computations in julia. Check <a href="https://github.com/SciML/NonlinearSolve.jl">NonlinearSolve.jl</a> for one prominent metapackage.</p></div></div><h2 id="GreenSolvers-without-support-for-ParametricHamiltonians"><a class="docs-heading-anchor" href="#GreenSolvers-without-support-for-ParametricHamiltonians">GreenSolvers without support for ParametricHamiltonians</a><a id="GreenSolvers-without-support-for-ParametricHamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#GreenSolvers-without-support-for-ParametricHamiltonians" title="Permalink"></a></h2><p>Some <code>GreenSolver</code>&#39;s, like <code>GS.KPM</code>, do not support <code>ParametricHamiltonian</code>s. In such cases, the approach above will fail, since it will not be possible to build <code>g</code> before knowing <code>phi</code>. In such cases one would need to rebuild the <code>meanfield</code> object at each step of the fixed-point solver. This is one way to do it.</p><pre><code class="language-julia hljs">julia&gt; using SIAMFANLEquations

julia&gt; h = LP.linear() |&gt; supercell(4) |&gt; supercell |&gt; onsite(1) - hopping(1) + @onsite((i; phi) --&gt; phi[i]);

julia&gt; M´(phi = zerofield) = meanfield(greenfunction(h(; phi), GS.Spectrum()); onsite = 1, selector = (; range = 0), fock = nothing)
M´ (generic function with 3 methods)

julia&gt; Φ0 = M´()(0.0, 0.0);

julia&gt; function f!(x, x0, (M´, Φ0))
        Φ = M´(deserialize(Φ0, x0))(0.0, 0.0)
        copy!(x, serialize(Φ))
        return x
           end;

julia&gt; m = 2; x0 = serialize(Φ0); vstore = rand(length(x0), 3m+3);  # order m, initial condition x0, and preallocated space vstore

julia&gt; x = aasol(f!, x0, m, vstore; pdata = (M´, Φ0)).solution
4-element Vector{ComplexF64}:
 0.15596283661234628 + 0.0im
 0.34403716338765444 + 0.0im
 0.34403716338765344 + 0.0im
 0.15596283661234572 + 0.0im</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../serializers/">« Serializers</a><a class="docs-footer-nextpage" href="../wannier90/">Wannier90 imports »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Thursday 30 October 2025 15:24">Thursday 30 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
