<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lattices · Quantica.jl</title><meta name="title" content="Lattices · Quantica.jl"/><meta property="og:title" content="Lattices · Quantica.jl"/><meta property="twitter:title" content="Lattices · Quantica.jl"/><meta name="description" content="Documentation for Quantica.jl."/><meta property="og:description" content="Documentation for Quantica.jl."/><meta property="twitter:description" content="Documentation for Quantica.jl."/><meta property="og:url" content="https://pablosanjose.github.io/Quantica.jl/tutorial/lattices/"/><meta property="twitter:url" content="https://pablosanjose.github.io/Quantica.jl/tutorial/lattices/"/><link rel="canonical" href="https://pablosanjose.github.io/Quantica.jl/tutorial/lattices/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Quantica.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Quantica.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Quantica.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../tutorial/">Welcome</a></li><li><a class="tocitem" href="../glossary/">Glossary</a></li><li class="is-active"><a class="tocitem" href>Lattices</a><ul class="internal"><li><a class="tocitem" href="#Constructing-a-Lattice-from-scratch"><span>Constructing a Lattice from scratch</span></a></li><li><a class="tocitem" href="#Lattice-presets"><span>Lattice presets</span></a></li><li><a class="tocitem" href="#Visualization"><span>Visualization</span></a></li><li><a class="tocitem" href="#siteselectors"><span>SiteSelectors</span></a></li><li><a class="tocitem" href="#Transforming-lattices"><span>Transforming lattices</span></a></li><li><a class="tocitem" href="#Currying:-chaining-transformations-with-the-operator"><span>Currying: chaining transformations with the <code>|&gt;</code> operator</span></a></li></ul></li><li><a class="tocitem" href="../models/">Models</a></li><li><a class="tocitem" href="../hamiltonians/">Hamiltonians</a></li><li><a class="tocitem" href="../bandstructures/">Bandstructures</a></li><li><a class="tocitem" href="../greenfunctions/">GreenFunctions</a></li><li><a class="tocitem" href="../observables/">Observables</a></li></ul></li><li><span class="tocitem">Advanced</span><ul><li><a class="tocitem" href="../../advanced/nonspatial/">Non-spatial models</a></li><li><a class="tocitem" href="../../advanced/serializers/">Serializers</a></li><li><a class="tocitem" href="../../advanced/meanfield/">Self-consistent mean fields</a></li><li><a class="tocitem" href="../../advanced/wannier90/">Wannier90 imports</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>Lattices</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lattices</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/pablosanjose/Quantica.jl/blob/master/docs/src/tutorial/lattices.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Lattices"><a class="docs-heading-anchor" href="#Lattices">Lattices</a><a id="Lattices-1"></a><a class="docs-heading-anchor-permalink" href="#Lattices" title="Permalink"></a></h1><h2 id="Constructing-a-Lattice-from-scratch"><a class="docs-heading-anchor" href="#Constructing-a-Lattice-from-scratch">Constructing a Lattice from scratch</a><a id="Constructing-a-Lattice-from-scratch-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-a-Lattice-from-scratch" title="Permalink"></a></h2><p>Consider a lattice like graphene&#39;s. It has two sublattices, A and B, forming a 2D honeycomb pattern in space. The position of site A and B inside the unitcell are <code>[0, -a0/(2√3)]</code> and <code>[0, a0/(2√3)]</code>, respectively. The Bravais vectors are <code>A₁, A₂ = a0 * [± cos(π/3), sin(π/3)]</code>. If we set the lattice constant to <code>a0 = √3</code> (so the carbon-carbon distance is 1), one way to build this lattice in Quantica.jl would be</p><pre><code class="language-julia hljs">julia&gt; A₁, A₂ = √3 .* (cos(π/3), sin(π/3)),
                √3 .* (-cos(π/3), sin(π/3));

julia&gt; sA, sB = sublat((0, -1/2), name = :A),
                sublat((0,  1/2), name = :B);

julia&gt; lattice(sA, sB, bravais = (A₁, A₂))
Lattice{Float64,2,2} : 2D lattice in 2D space
  Bravais vectors : [[0.866025, 1.5], [-0.866025, 1.5]]
  Sublattices     : 2
    Names         : (:A, :B)
    Sites         : (1, 1) --&gt; 2 total per unit cell</code></pre><div class="admonition is-success" id="Tuple,-SVector-and-SMatrix-a39fef17fc1c486a"><header class="admonition-header">Tuple, SVector and SMatrix<a class="admonition-anchor" href="#Tuple,-SVector-and-SMatrix-a39fef17fc1c486a" title="Permalink"></a></header><div class="admonition-body"><p>Note that we have used <code>Tuple</code>s, such as <code>(0, 1/2)</code> instead of <code>Vector</code>s, like <code>[0, 1/2]</code>. In Julia small-length <code>Tuple</code>s are much more efficient as containers than <code>Vector</code>s, since their length is known and fixed at compile time. Static vectors (<code>SVector</code>) and matrices (<code>SMatrix</code>) are also available to Quantica, which are just as efficient as <code>Tuple</code>s, and they also implement linear algebra operations. They may be entered as e.g. <code>SA[0, 1/2]</code> and <code>SA[1 0; 0 1]</code>, respectively. For efficiency, always use <code>Tuple</code>, <code>SVector</code> and <code>SMatrix</code> in Quantica.jl where possible.</p></div></div><p>If we don&#39;t plan to address the two sublattices individually, we could also fuse them into one, like</p><pre><code class="language-julia hljs">julia&gt; lat = lattice(sublat((0, 1/2), (0, -1/2)), bravais = (A₁, A₂))
Lattice{Float64,2,2} : 2D lattice in 2D space
  Bravais vectors : [[0.866025, 1.5], [-0.866025, 1.5]]
  Sublattices     : 1
    Names         : (:A,)
    Sites         : (2,) --&gt; 2 total per unit cell</code></pre><p>This lattice has type <code>Lattice{T,E,L}</code>, with <code>T = Float64</code> the numeric type of position coordinates, <code>E = 2</code> the dimension of embedding space, and <code>L = 2</code> the number of Bravais vectors (i.e. the lattice dimension). Both <code>T</code> and <code>E</code>, and even the <code>Sublat</code> names can be overridden when creating a lattice. One can also provide the Bravais vectors as a matrix, with each <code>Aᵢ</code> as a column.</p><pre><code class="language-julia hljs">julia&gt; Amat = √3 * SA[-cos(π/3) cos(π/3); sin(π/3) sin(π/3)];

julia&gt; lat´ = lattice(sA, sB, bravais = Amat, type = Float32, dim = 3, names = (:C, :D))
Lattice{Float32,3,2} : 2D lattice in 3D space
  Bravais vectors : Vector{Float32}[[-0.866025, 1.5, 0.0], [0.866025, 1.5, 0.0]]
  Sublattices     : 2
    Names         : (:C, :D)
    Sites         : (1, 1) --&gt; 2 total per unit cell</code></pre><div class="admonition is-success" id="Advanced:-dim-Val(E)-vs.-dim-E-97f8be0fce23daa2"><header class="admonition-header">Advanced: `dim = Val(E)` vs. `dim = E`<a class="admonition-anchor" href="#Advanced:-dim-Val(E)-vs.-dim-E-97f8be0fce23daa2" title="Permalink"></a></header><div class="admonition-body"><p>For the <code>dim</code> keyword above we can alternatively use <code>dim = Val(3)</code>, which is slightly more efficient, because the value is encoded as a type. This is a &quot;Julia thing&quot; (related to the concept of type stability), and can be ignored upon a first contact with Quantica.jl.</p></div></div><p>One can also <em>convert</em> an existing lattice like the above to have a different type, embedding dimension, Bravais vectors and <code>Sublat</code> names with <code>lattice(lat; kw...)</code>. For example</p><pre><code class="language-julia hljs">julia&gt; lat´´ = lattice(lat´, type = Float16, dim = 2, names = (:Boron, :Nitrogen))
Lattice{Float16,2,2} : 2D lattice in 2D space
  Bravais vectors : Vector{Float16}[[-0.866, 1.5], [0.866, 1.5]]
  Sublattices     : 2
    Names         : (:Boron, :Nitrogen)
    Sites         : (1, 1) --&gt; 2 total per unit cell</code></pre><p>A list of site positions in a lattice <code>lat</code> can be obtained with <code>sites(lat)</code>, or <code>sites(lat, sublat)</code> to restrict to a specific sublattice</p><pre><code class="language-julia hljs">julia&gt; sites(lat´´)
2-element Vector{SVector{2, Float16}}:
 [0.0, -0.5]
 [0.0, 0.5]

julia&gt; sites(lat´´, :Nitrogen)
1-element view(::Vector{SVector{2, Float16}}, 2:2) with eltype SVector{2, Float16}:
 [0.0, 0.5]</code></pre><p>Similarly, the Bravais matrix of a <code>lat</code> can be obtained with <code>bravais_matrix(lat)</code>.</p><h2 id="Lattice-presets"><a class="docs-heading-anchor" href="#Lattice-presets">Lattice presets</a><a id="Lattice-presets-1"></a><a class="docs-heading-anchor-permalink" href="#Lattice-presets" title="Permalink"></a></h2><p>Quantica.jl provides a range of presets. A preset is a pre-built object of some type. In particular we have Lattice presets, defined in the submodule <code>LatticePresets</code> (also called <code>LP</code> for convenience), that include a number of classical lattices in different dimensions:</p><ul><li><code>LP.linear</code>: linear 1D lattice</li><li><code>LP.square</code>: square 2D lattice</li><li><code>LP.honeycomb</code>: honeycomb 2D lattice</li><li><code>LP.cubic</code>: cubic 3D lattice</li><li><code>LP.bcc</code>: body-centered cubic 3D lattice</li><li><code>LP.fcc</code>: face-centered cubic 3D lattice</li></ul><p>To obtain a lattice from a preset one simply calls it, e.g. <code>LP.honecyomb(; kw...)</code>. One can modify any of these <code>LatticePresets</code> by passing a <code>bravais</code>, <code>type</code>, <code>dim</code> or <code>names</code> keyword. One can also use a new keyword <code>a0</code> for the lattice constant (<code>a0 = 1</code> by default). The lattice <code>lat´´</code> above can thus be also obtained with</p><pre><code class="language-julia hljs">julia&gt; lat´´ = LP.honeycomb(a0 = √3, type = Float16, names = (:Boron, :Nitrogen))
Lattice{Float16,2,2} : 2D lattice in 2D space
  Bravais vectors : Vector{Float16}[[0.866, 1.5], [-0.866, 1.5]]
  Sublattices     : 2
    Names         : (:Boron, :Nitrogen)
    Sites         : (1, 1) --&gt; 2 total per unit cell</code></pre><div class="admonition is-success" id="Quantica&#39;s-Presets-library-8960b891c734391d"><header class="admonition-header">Quantica&#39;s Presets library<a class="admonition-anchor" href="#Quantica&#39;s-Presets-library-8960b891c734391d" title="Permalink"></a></header><div class="admonition-body"><p>Quantica comes with four submodules that provide different kinds of presets: <code>LatticePresets</code> (<code>LP</code>), <code>HamiltonianPresets</code> (<code>HP</code>), <code>RegionPresets</code> (<code>RP</code>) and <code>ExternalPresets</code> (<code>EP</code>). <code>LP</code> provides a collection of standard lattices, <code>HP</code> some premade model Hamiltonians such as <code>HP.graphene</code> or <code>HP.twisted_bilayer_graphene</code>, <code>RP</code> some geometric regions such as <code>RP.circle</code> or <code>RP.cuboid</code>, and <code>EP</code> some importers of externally produced objects such as <code>EP.wannier90</code> to import Wannier90 files (see <code>Advanced</code> for details on the latter). This library of presets is expected to grow with time. The docstring for the submodule or the preset function can be queried for a description of the available options.</p></div></div><h2 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h2><p>To produce an interactive visualization of <code>Lattice</code>s or other Quantica.jl object you need to load GLMakie.jl, CairoMakie.jl or some other plotting backend from the Makie repository (i.e. do <code>using GLMakie</code>, see also Installation). Then, a number of new plotting functions will become available. The main one is <code>qplot</code>. A <code>Lattice</code> is represented, by default, as the sites in a unitcell plus the Bravais vectors.</p><pre><code class="language-julia hljs">julia&gt; using GLMakie

julia&gt; lat = LP.honeycomb()

julia&gt; qplot(lat, hide = nothing)</code></pre><img src="../../assets/honeycomb_lat.png" alt="Honeycomb lattice" width="250" class="center"/><p><code>qplot</code> accepts a large number of keywords to customize your plot. In the case of lattice, most of these are passed over to the function <code>plotlattice</code>, specific to <code>Lattices</code> and <code>Hamiltonians</code>. In the case above, <code>hide = nothing</code> means &quot;don&#39;t hide any element of the plot&quot;. See the <code>qplot</code> and <code>plotlattice</code> docstrings for details.</p><div class="admonition is-success" id="GLMakie.jl-vs-CairoMakie.jl-5ff09ee33e19d000"><header class="admonition-header">GLMakie.jl vs CairoMakie.jl<a class="admonition-anchor" href="#GLMakie.jl-vs-CairoMakie.jl-5ff09ee33e19d000" title="Permalink"></a></header><div class="admonition-body"><p>GLMakie.jl is optimized for interactive GPU-accelerated, rasterized plots. If you need to export to PDF for publications or display plots inside a Jupyter notebook, use CairoMakie.jl instead, which in general renders non-interactive, but vector-based plots.</p></div></div><div class="admonition is-success" id="User-defined-defaults-for-qplot-e9ea2beb7b817ca5"><header class="admonition-header">User-defined defaults for `qplot`<a class="admonition-anchor" href="#User-defined-defaults-for-qplot-e9ea2beb7b817ca5" title="Permalink"></a></header><div class="admonition-body"><p>The command <code>qplotdefaults(; axis, figure)</code> can be used to define the default value of <code>figure</code> and <code>axis</code> keyword arguments of <code>qplot</code>. Example: to fix the size of all subsequent plots, do <code>qplotdefaults(; figure = (size = (1000, 1000),))</code>.</p></div></div><h2 id="siteselectors"><a class="docs-heading-anchor" href="#siteselectors">SiteSelectors</a><a id="siteselectors-1"></a><a class="docs-heading-anchor-permalink" href="#siteselectors" title="Permalink"></a></h2><p>A central concept in Quantica.jl is that of a &quot;selector&quot;. There are two types of selectors, <code>SiteSelector</code>s and <code>HopSelectors</code>. <code>SiteSelector</code>s are a set of directives or rules that define a subset of its sites. <code>SiteSelector</code> rules are defined through three keywords:</p><ul><li><code>region</code>: a boolean function of allowed site positions <code>r</code>.</li><li><code>sublats</code>: allowed sublattices of selected sites</li><li><code>cells</code>: allowed cell indices of selected sites</li></ul><p>Similarly, <code>HopSelector</code>s can be used to select a number of site pairs, and will be used later to define hoppings in tight-binding models (see further below).</p><p>As an example, let us define a <code>SiteSelector</code> that picks all sites belonging to the <code>:B</code> sublattice of a given lattice within a circle of radius <code>10</code></p><pre><code class="language-julia hljs">julia&gt; s = siteselector(region = r -&gt; norm(r) &lt;= 10, sublats = :B)
SiteSelector: a rule that defines a finite collection of sites in a lattice
  Region            : Function
  Sublattices       : B
  Cells             : any</code></pre><p>Note that this selector is defined independently of the lattice. To apply it to a lattice <code>lat</code> we do <code>lat[s]</code>, which results in a <code>LatticeSlice</code> (i.e. a finite portion, or slice, of <code>lat</code>)</p><pre><code class="language-julia hljs">julia&gt; lat = LP.honeycomb(); lat[s]
LatticeSlice{Float64,2,2} : collection of subcells for a 2D lattice in 2D space
  Cells       : 363
  Cell range  : ([-11, -11], [11, 11])
  Total sites : 363</code></pre><p>The <code>Cell range</code> above are the corners of a bounding box <em>in cell-index space</em> that contains all unit cell indices with at least one selected site.</p><p>Let&#39;s plot it</p><pre><code class="language-julia hljs">julia&gt; qplot(lat[s], hide = ())</code></pre><img src="../../assets/latslice.png" alt="A LatticeSlice" width="400" class="center"/><div class="admonition is-success" id="qplot-selector-b2e8d9cd926d3de8"><header class="admonition-header">qplot selector<a class="admonition-anchor" href="#qplot-selector-b2e8d9cd926d3de8" title="Permalink"></a></header><div class="admonition-body"><p>The above <code>qplot(lat[s])</code> can also be written as <code>qplot(lat, selector = s)</code>, which will be useful when plotting <code>AbstractHamiltonians</code>.</p></div></div><div class="admonition is-success" id="Sites-of-a-LatticeSlice-47551bded907a4b0"><header class="admonition-header">Sites of a LatticeSlice<a class="admonition-anchor" href="#Sites-of-a-LatticeSlice-47551bded907a4b0" title="Permalink"></a></header><div class="admonition-body"><p>Collect the site positions of a <code>LatticeSlice</code> into a vector with <code>collect(sites(ls))</code>. If you do <code>sites(ls)</code> instead, you will get a lazy generator that can be used to iterate efficiently among site positions without allocating them in memory.</p></div></div><p>Apart from <code>region</code> and <code>sublats</code> we can also restrict the unitcells by their cell index. For example, to select all sites in unit cells within the above bounding box we can do</p><pre><code class="language-julia hljs">julia&gt; s´ = siteselector(cells = CartesianIndices((-11:11, -11:11)))
SiteSelector: a rule that defines a finite collection of sites in a lattice
  Region            : any
  Sublattices       : any
  Cells             : CartesianIndices((-11:11, -11:11))

julia&gt; lat[s´]
LatticeSlice{Float64,2,2} : collection of subcells for a 2D lattice in 2D space
  Cells       : 529
  Cell range  : ([-11, -11], [11, 11])
  Total sites : 1058</code></pre><p>We can often omit constructing the <code>SiteSelector</code> altogether by using the keywords directly</p><pre><code class="language-julia hljs">julia&gt; ls = lat[cells = n -&gt; 0 &lt;= n[1] &lt;= 2 &amp;&amp; abs(n[2]) &lt; 3, sublats = :A]
LatticeSlice{Float64,2,2} : collection of subcells for a 2D lattice in 2D space
  Cells       : 15
  Cell range  : ([0, -2], [2, 2])
  Total sites : 15</code></pre><p>Selectors are very expressive and powerful. Do check <code>siteselector</code> and <code>hopselector</code> docstrings for more details.</p><h2 id="Transforming-lattices"><a class="docs-heading-anchor" href="#Transforming-lattices">Transforming lattices</a><a id="Transforming-lattices-1"></a><a class="docs-heading-anchor-permalink" href="#Transforming-lattices" title="Permalink"></a></h2><p>We can transform lattices using <code>supercell</code>, <code>reverse</code>, <code>transform</code>, <code>translate</code>.</p><p>As a periodic structure, the choice of the unitcell in an unbounded lattice is, to an extent, arbitrary. Given a lattice <code>lat</code> we can obtain another with a unit cell 3 times larger with <code>supercell(lat, 3)</code></p><pre><code class="language-julia hljs">julia&gt; lat = supercell(LP.honeycomb(), 3)
Lattice{Float64,2,2} : 2D lattice in 2D space
  Bravais vectors : [[1.5, 2.598076], [-1.5, 2.598076]]
  Sublattices     : 2
    Names         : (:A, :B)
    Sites         : (9, 9) --&gt; 18 total per unit cell</code></pre><p>More generally, given a lattice <code>lat</code> with Bravais matrix <code>Amat = bravais_matrix(lat)</code>, we can obtain a larger one with Bravais matrix <code>Amat´ = Amat * S</code>, where <code>S</code> is a square matrix of integers. In the example above, <code>S = SA[3 0; 0 3]</code>. The columns of <code>S</code> represent the coordinates of the new Bravais vectors in the basis of the old Bravais vectors. A more general example with e.g. <code>S = SA[3 1; -1 2]</code> can be written either in terms of <code>S</code> or of its columns</p><pre><code class="language-julia hljs">julia&gt; supercell(lat, SA[3 1; -1 2]) == supercell(lat, (3, -1), (1, 2))
true</code></pre><p>We can also use <code>supercell</code> to reduce the number of Bravais vectors, and hence the lattice dimensionality. To construct a new lattice with a single Bravais vector <code>A₁´ = 3A₁ - A₂</code>, just omit the second one</p><pre><code class="language-julia hljs">julia&gt; supercell(lat, (3, -1))
Lattice{Float64,2,1} : 1D lattice in 2D space
  Bravais vectors : [[6.0, 5.196152]]
  Sublattices     : 2
    Names         : (:A, :B)
    Sites         : (27, 27) --&gt; 54 total per unit cell</code></pre><p>Its important to note that the lattice will be bounded along directions different from the specified Bravais vectors. With the syntax above, the new unitcell will be minimal. We may however define how many sites to include in the new unitcell by adding a <code>SiteSelector</code> directive to be applied in the non-periodic directions. For example, to create a 10 * a0 wide, honeycomb nanoribbon we can do</p><pre><code class="language-julia hljs">julia&gt; lat = supercell(LP.honeycomb(), (1,-1), region = r -&gt; -5 &lt;= r[2] &lt;= 5)
Lattice{Float64,2,1} : 1D lattice in 2D space
  Bravais vectors : [[1.0, 0.0]]
  Sublattices     : 2
    Names         : (:A, :B)
    Sites         : (12, 12) --&gt; 24 total per unit cell

julia&gt; qplot(lat[cells = -7:7])</code></pre><img src="../../assets/nanoribbon_lat.png" alt="Honeycomb nanoribbon" width="350" class="center"/><div class="admonition is-success" id="No-need-to-build-selectors-explicitly-5852eb7ba655a92"><header class="admonition-header">No need to build selectors explicitly<a class="admonition-anchor" href="#No-need-to-build-selectors-explicitly-5852eb7ba655a92" title="Permalink"></a></header><div class="admonition-body"><p>Note that we we didn&#39;t build a <code>siteselector(region = ...)</code> object to pass it to <code>supercell</code>. Instead, as shown above, we passed the corresponding keywords directly to <code>supercell</code>, which then takes care to build the selector internally.</p></div></div><p>To simply reverse the direction of the Bravais vectors of a lattice, while leaving the site positions unchanged, use <code>reverse</code> (or <code>reverse!</code> to do it in-place)</p><pre><code class="language-julia hljs">julia&gt; reverse(LP.square())
Lattice{Float64,2,2} : 2D lattice in 2D space
  Bravais vectors : [[-1.0, -0.0], [-0.0, -1.0]]
  Sublattices     : 1
    Names         : (:A,)
    Sites         : (1,) --&gt; 1 total per unit cell</code></pre><p>To transform a lattice, so that site positions <code>r</code> become <code>f(r)</code> use <code>transform</code></p><pre><code class="language-julia hljs">julia&gt; f(r) = SA[0 1; 1 0] * r
f (generic function with 1 method)

julia&gt; rotated_honeycomb = transform(LP.honeycomb(a0 = √3), f)
Lattice{Float64,2,2} : 2D lattice in 2D space
  Bravais vectors : [[1.5, 0.866025], [1.5, -0.866025]]
  Sublattices     : 2
    Names         : (:A, :B)
    Sites         : (1, 1) --&gt; 2 total per unit cell

julia&gt; sites(rotated_honeycomb)
2-element Vector{SVector{2, Float64}}:
 [-0.5, 0.0]
 [0.5, 0.0]</code></pre><p>To translate a lattice by a displacement vector <code>δr</code> use <code>translate</code></p><pre><code class="language-julia hljs">julia&gt; δr = SA[0, 1];

julia&gt; sites(translate(rotated_honeycomb, δr))
2-element Vector{SVector{2, Float64}}:
 [-0.5, 1.0]
 [0.5, 1.0]</code></pre><h2 id="Currying:-chaining-transformations-with-the-operator"><a class="docs-heading-anchor" href="#Currying:-chaining-transformations-with-the-operator">Currying: chaining transformations with the <code>|&gt;</code> operator</a><a id="Currying:-chaining-transformations-with-the-operator-1"></a><a class="docs-heading-anchor-permalink" href="#Currying:-chaining-transformations-with-the-operator" title="Permalink"></a></h2><p>Many functions in Quantica.jl have a &quot;curried&quot; version that allows them to be chained together using the pipe operator <code>|&gt;</code>.</p><div class="admonition is-info" id="Definition-of-currying-e1148c5b62530d63"><header class="admonition-header">Definition of currying<a class="admonition-anchor" href="#Definition-of-currying-e1148c5b62530d63" title="Permalink"></a></header><div class="admonition-body"><p>The curried version of a function <code>f(x1, x2...)</code> is <code>f´ = x1 -&gt; f(x2...)</code>, so that the curried form of <code>f(x1, x2...)</code> is <code>x2 |&gt; f´(x2...)</code>, or <code>f´(x2...)(x1)</code>. This gives the first argument <code>x1</code> a privileged role. Users of object-oriented languages such as Python may find this use of the <code>|&gt;</code> operator somewhat similar to the way the dot operator works there (i.e. <code>x1.f(x2...)</code>).</p></div></div><p>The last example above can then be written as</p><pre><code class="language-julia hljs">julia&gt; LP.honeycomb(a0 = √3) |&gt; transform(f) |&gt; translate(δr) |&gt; sites
2-element Vector{SVector{2, Float64}}:
 [-0.5, 1.0]
 [0.5, 1.0]</code></pre><p>This type of curried syntax is natural in Quantica, and will be used extensively in this tutorial.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../glossary/">« Glossary</a><a class="docs-footer-nextpage" href="../models/">Models »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 1 October 2025 13:45">Wednesday 1 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
