<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>GreenFunctions · Quantica.jl</title><meta name="title" content="GreenFunctions · Quantica.jl"/><meta property="og:title" content="GreenFunctions · Quantica.jl"/><meta property="twitter:title" content="GreenFunctions · Quantica.jl"/><meta name="description" content="Documentation for Quantica.jl."/><meta property="og:description" content="Documentation for Quantica.jl."/><meta property="twitter:description" content="Documentation for Quantica.jl."/><meta property="og:url" content="https://pablosanjose.github.io/Quantica.jl/tutorial/greenfunctions/"/><meta property="twitter:url" content="https://pablosanjose.github.io/Quantica.jl/tutorial/greenfunctions/"/><link rel="canonical" href="https://pablosanjose.github.io/Quantica.jl/tutorial/greenfunctions/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Quantica.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Quantica.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Quantica.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../tutorial/">Welcome</a></li><li><a class="tocitem" href="../glossary/">Glossary</a></li><li><a class="tocitem" href="../lattices/">Lattices</a></li><li><a class="tocitem" href="../models/">Models</a></li><li><a class="tocitem" href="../hamiltonians/">Hamiltonians</a></li><li><a class="tocitem" href="../bandstructures/">Bandstructures</a></li><li class="is-active"><a class="tocitem" href>GreenFunctions</a><ul class="internal"><li><a class="tocitem" href="#A-simple-example"><span>A simple example</span></a></li><li><a class="tocitem" href="#GreenSolvers"><span>GreenSolvers</span></a></li><li><a class="tocitem" href="#Attaching-Contacts"><span>Attaching Contacts</span></a></li><li><a class="tocitem" href="#A-more-advanced-example"><span>A more advanced example</span></a></li><li><a class="tocitem" href="#Slicing-and-evaluation"><span>Slicing and evaluation</span></a></li><li><a class="tocitem" href="#Visualizing-a-Green-function"><span>Visualizing a Green function</span></a></li></ul></li><li><a class="tocitem" href="../observables/">Observables</a></li></ul></li><li><span class="tocitem">Advanced</span><ul><li><a class="tocitem" href="../../advanced/nonspatial/">Non-spatial models</a></li><li><a class="tocitem" href="../../advanced/serializers/">Serializers</a></li><li><a class="tocitem" href="../../advanced/meanfield/">Self-consistent mean fields</a></li><li><a class="tocitem" href="../../advanced/wannier90/">Wannier90 imports</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>GreenFunctions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>GreenFunctions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/pablosanjose/Quantica.jl/blob/master/docs/src/tutorial/greenfunctions.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="GreenFunctions"><a class="docs-heading-anchor" href="#GreenFunctions">GreenFunctions</a><a id="GreenFunctions-1"></a><a class="docs-heading-anchor-permalink" href="#GreenFunctions" title="Permalink"></a></h1><p>Up to now we have seen how to define Lattices, Models, Hamiltonians and Bandstructures. Most problems require the computation of different physical observables for these objects, e.g. the local density of states or various transport coefficients. We reduce this general problem to the computation of the retarded Green function</p><p><span>$G^r_{ij}(\omega) = \langle i|(\omega-H-\Sigma(\omega))^{-1}|j\rangle$</span></p><p>where <code>i, j</code> are orbitals, <code>H</code> is the (possibly infinite) Hamiltonian matrix, and <code>Σ(ω)</code> is the self-energy coming from any coupling to other systems (typically described by their own <code>AbstractHamiltonian</code>).</p><p>We split the problem of computing <code>Gʳᵢⱼ(ω)</code> of a given <code>h::AbstractHamiltonian</code> into four steps:</p><ol><li>Attach self-energies to <code>h</code> using the command <code>oh = attach(h, args...)</code>. This produces a new object <code>oh::OpenHamiltonian</code> with a number of <code>Contacts</code>, numbered <code>1</code> to <code>N</code></li><li>Use <code>g = greenfunction(oh, solver)</code> to build a <code>g::GreenFunction</code> representing <code>Gʳ</code> (at arbitrary <code>ω</code> and <code>i,j</code>), where <code>oh::OpenHamiltonian</code> and <code>solver::AbstractGreenSolver</code> (see <code>GreenSolvers</code> below for available solvers)</li><li>Evaluate <code>gω = g(ω; params...)</code> at fixed energy <code>ω</code> and model parameters, which produces a <code>gω::GreenSolution</code></li><li>Slice <code>gω[sᵢ, sⱼ]</code> or <code>gω[sᵢ] == gω[sᵢ, sᵢ]</code> to obtain <code>Gʳᵢⱼ(ω)</code> as a flat matrix, where <code>sᵢ, sⱼ</code> are either site selectors over sites spanning orbitals <code>i,j</code>, integers denoting contacts, <code>1</code> to <code>N</code>, or <code>:</code> denoting all contacts merged together.</li></ol><div class="admonition is-success"><header class="admonition-header">GreenSlice vs. GreenSolution</header><div class="admonition-body"><p>The two last steps can be interchanged, by first obtaining a <code>gs::GreenSlice</code> with <code>gs = g[sᵢ, sⱼ]</code> and then obtaining the <code>Gʳᵢⱼ(ω)</code> matrix with <code>gs(ω; params...)</code>.</p></div></div><h2 id="A-simple-example"><a class="docs-heading-anchor" href="#A-simple-example">A simple example</a><a id="A-simple-example-1"></a><a class="docs-heading-anchor-permalink" href="#A-simple-example" title="Permalink"></a></h2><p>Here is a simple example of the Green function of a 1D lead with two sites per unit cell, a boundary at <code>cell = 0</code>, and with no attached self-energies for simplicity</p><pre><code class="nohighlight hljs">julia&gt; hlead = LP.square() |&gt; supercell((1,0), region = r -&gt; 0 &lt;= r[2] &lt; 2) |&gt; hopping(1);

julia&gt; glead = greenfunction(hlead, GreenSolvers.Schur(boundary = 0))
GreenFunction{Float64,2,1}: Green function of a Hamiltonian{Float64,2,1}
  Solver          : AppliedSchurGreenSolver
  Contacts        : 0
  Contact solvers : ()
  Contact sizes   : ()
  Hamiltonian{Float64,2,1}: Hamiltonian on a 1D Lattice in 2D space
    Bloch harmonics  : 3
    Harmonic size    : 2 × 2
    Orbitals         : [1]
    Element type     : scalar (ComplexF64)
    Onsites          : 0
    Hoppings         : 6
    Coordination     : 3.0

julia&gt; gω = glead(0.2)  # we first fix energy to ω = 0.2
GreenSolution{Float64,2,1}: Green function at arbitrary positions, but at a fixed energy

julia&gt; gω[cells = 1:2]  # we now ask for the Green function between orbitals in the first two unit cells to the righht of the boundary
4×4 Matrix{ComplexF64}:
   0.1-0.858258im    -0.5-0.0582576im  -0.48-0.113394im   -0.2+0.846606im
  -0.5-0.0582576im    0.1-0.858258im    -0.2+0.846606im  -0.48-0.113394im
 -0.48-0.113394im    -0.2+0.846606im   0.104-0.869285im   0.44+0.282715im
  -0.2+0.846606im   -0.48-0.113394im    0.44+0.282715im  0.104-0.869285im</code></pre><p>Note that the result is a 4 x 4 matrix, because there are 2 orbitals (one per site) in each of the two unit cells. Note also that the <code>GreenSolvers.Schur</code> used here allows us to compute the Green function between distant cells with little overhead</p><pre><code class="language-julia hljs">julia&gt; @time gω[cells = 1:2];
  0.000067 seconds (70 allocations: 6.844 KiB)

julia&gt; @time gω[cells = (SA[10], SA[100000])];
  0.000098 seconds (229 allocations: 26.891 KiB)</code></pre><h2 id="GreenSolvers"><a class="docs-heading-anchor" href="#GreenSolvers">GreenSolvers</a><a id="GreenSolvers-1"></a><a class="docs-heading-anchor-permalink" href="#GreenSolvers" title="Permalink"></a></h2><p>The currently implemented <code>GreenSolvers</code> (abbreviated as <code>GS</code>) are the following</p><ul><li><p><code>GS.SparseLU()</code></p><p>For bounded (<code>L=0</code>) AbstractHamiltonians. Default for <code>L=0</code>.</p><p>Uses a sparse <code>LU</code> factorization to compute the inverse of <code>⟨i|ω - H - Σ(ω)|j⟩</code>, where <code>Σ(ω)</code> is the self-energy from the contacts.</p></li></ul><ul><li><p><code>GS.Spectrum(; spectrum_kw...)</code></p><p>For bounded (<code>L=0</code>) Hamiltonians. This solver does not accept ParametricHamiltonians. Convert to Hamiltonian with <code>h(; params...)</code> first.</p><p>Uses a diagonalization of <code>H</code>, obtained with <code>spectrum(H; spectrum_kw...)</code>, to compute the <code>G⁰ᵢⱼ</code> using the Lehmann representation <code>∑ₖ⟨i|ϕₖ⟩⟨ϕₖ|j⟩/(ω - ϵₖ)</code>. Any eigensolver supported by <code>spectrum</code> can be used here. If there are contacts, it dresses <code>G⁰</code> using a T-matrix approach, <code>G = G⁰ + G⁰TG⁰</code>.</p></li></ul><ul><li><p><code>GS.KPM(order = 100, bandrange = missing, kernel = I)</code></p><p>For bounded (<code>L=0</code>) Hamiltonians, and restricted to sites belonging to contacts (see the section on Contacts).</p><p>It precomputes the Chebyshev momenta, and incorporates the contact self energy with a T-matrix approach.</p></li></ul><ul><li><p><code>GS.Schur(boundary = Inf)</code></p><p>For 1D (<code>L=1</code>) AbstractHamiltonians with only nearest-cell coupling. Default for <code>L=1</code>.</p><p>Uses a deflating Generalized Schur (QZ) factorization of the generalized eigenvalue problem to compute the unit-cell self energies. The Dyson equation then yields the Green function between arbitrary unit cells, which is further dressed using a T-matrix approach if the lead has any attached self-energy.</p></li></ul><ul><li><p><code>GS.Bands(bandsargs...; boundary = missing, bandskw...)</code></p><p>For unbounded (<code>L&gt;0</code>) Hamiltonians.</p><p>It precomputes a bandstructure <code>b = bands(h, bandsargs...; kw..., split = false)</code> and then uses analytic expressions for the contribution of each subband simplex to the <code>GreenSolution</code>. If <code>boundary = dir =&gt; cell_pos</code>, it takes into account the reflections on an infinite boundary perpendicular to Bravais vector number <code>dir</code>, so that all sites with cell index <code>c[dir] &lt;= cell_pos</code> are removed. Contacts are incorporated using a T-matrix approach.</p><p>To retrieve the bands from a <code>g::GreenFunction</code> that used the <code>GS.Bands</code> solver, we may use <code>bands(g)</code>.</p></li></ul><h2 id="Attaching-Contacts"><a class="docs-heading-anchor" href="#Attaching-Contacts">Attaching Contacts</a><a id="Attaching-Contacts-1"></a><a class="docs-heading-anchor-permalink" href="#Attaching-Contacts" title="Permalink"></a></h2><p>A self energy <code>Σ(ω)</code> acting of a finite set of sites of <code>h</code> (i.e. on a <code>LatticeSlice</code> of <code>lat = lattice(h)</code>) can be incorporated using the <code>attach</code> command. This defines a new Contact in <code>h</code>. The general syntax is <code>oh = attach(h, args...; sites...)</code>, where the <code>sites</code> directives define the Contact <code>LatticeSlice</code> (<code>lat[siteselector(; sites...)]</code>), and <code>args</code> can take a number of forms.</p><p>The supported <code>attach</code> forms are the following</p><ul><li><p><strong>Generic self-energy</strong></p><p><code>attach(h, gs::GreenSlice, coupling::AbstractModel; sites...)</code></p><p>This is the generic form of <code>attach</code>, which couples some sites <code>i</code> of a <code>g::Greenfunction</code> (defined by the slice <code>gs = g[i]</code>), to <code>sites</code> of <code>h</code> using a <code>coupling</code> model. This results in a self-energy <code>Σ(ω) = V´⋅gs(ω)⋅V</code> on <code>h</code> <code>sites</code>, where <code>V</code> and <code>V´</code> are couplings matrices given by <code>coupling</code>.</p></li></ul><ul><li><p><strong>Dummy self-energy</strong></p><p><code>attach(h, nothing; sites...)</code></p><p>This form merely defines a new contact on the specified <code>sites</code>, but  adds no actual self-energy to it. It is meant as a way to refer to some sites of interest using the <code>g[i::Integer]</code> slicing syntax for <code>GreenFunction</code>s, where <code>i</code> is the contact index.</p></li></ul><ul><li><p><strong>Model self-energy</strong></p><p><code>attach(h, model::AbstractModel; sites...)</code></p><p>This form defines a self-energy <code>Σᵢⱼ(ω)</code> in terms of <code>model</code>, which must be composed purely of parametric terms (<code>@onsite</code> and <code>@hopping</code>) that have <code>ω</code> as first argument, as in e.g. <code>@onsite((ω, r) -&gt; Σᵢᵢ(ω, r))</code> or <code>@hopping((ω, r, dr) -&gt; Σᵢⱼ(ω, r, dr))</code>. This is a modellistic approach, wherein the self-energy is not computed from the properties of another <code>AbstractHamiltonian</code>, but rather has an arbitrary form defined by the user.</p></li></ul><ul><li><p><strong>Matched lead self-energy</strong></p><p><code>attach(h, glead::GreenFunction; reverse = false, transform = identity, sites...)</code></p><p>Here <code>glead</code> is a GreenFunction of a 1D lead, possibly with a boundary.</p><p>With this syntax <code>sites</code> must select a number of sites in <code>h</code> whose position match (after applying <code>transform</code> to them and modulo an arbitrary displacement) the sites in the unit cell of <code>glead</code>. Then, the coupling between these and the first unit cell of <code>glead</code> on the positive side of the boundary will be the same as between <code>glead</code> unitcells, i.e. <code>V = hlead[(1,)]</code>, where <code>hlead = hamiltonian(glead)</code>.</p><p>If <code>reverse == true</code>, the lead is reversed before being attached, so that h is coupled through <code>V = hlead[(-1,)]</code> to the first unitcell on the negative side of the boundary. If there is no boundary, the <code>cell = 0</code> unitcell of the <code>glead</code> is used.</p></li></ul><ul><li><p><strong>Generic lead self-energy</strong></p><p><code>attach(h, glead::GreenFunction, model::AbstractModel; reverse = false, transform = identity, sites...)</code></p><p>The same as above, but without any restriction on <code>sites</code>. The coupling between these and the first unit cell of <code>glead</code> (transformed by <code>transform</code>) is constructed using <code>model::TightbindingModel</code>. The &quot;first unit cell&quot; is defined as above.</p></li></ul><h2 id="A-more-advanced-example"><a class="docs-heading-anchor" href="#A-more-advanced-example">A more advanced example</a><a id="A-more-advanced-example-1"></a><a class="docs-heading-anchor-permalink" href="#A-more-advanced-example" title="Permalink"></a></h2><p>Let us define the classical example of a multiterminal mesoscopic junction. We choose a square lattice, and a circular central region of radius <code>10</code>, with four leads of width <code>5</code> coupled to it at right angles.</p><p>We first define a single lead <code>Greenfunction</code> and the central Hamiltonian</p><pre><code class="language-julia hljs">julia&gt; glead = LP.square() |&gt; onsite(4) - hopping(1) |&gt; supercell((1, 0), region = r -&gt; abs(r[2]) &lt;= 5/2) |&gt; greenfunction(GS.Schur(boundary = 0));

julia&gt; hcentral = LP.square() |&gt; onsite(4) - hopping(1) |&gt; supercell(region = RP.circle(10) | RP.rectangle((22, 5)) | RP.rectangle((5, 22)));</code></pre><p>The two rectangles overlayed on the circle above create the stubs where the leads will be attached:</p><img src="../../assets/central.png" alt="Central region with stubs" width="250" class="center"/><p>We now attach <code>glead</code> four times using the <code>Matched lead</code> syntax</p><pre><code class="language-julia hljs">julia&gt; Rot = r -&gt; SA[0 -1; 1 0] * r;  # 90º rotation function

julia&gt; g = hcentral |&gt;
    attach(glead, region = r -&gt; r[1] ==  11) |&gt;
    attach(glead, region = r -&gt; r[1] == -11, reverse = true) |&gt;
    attach(glead, region = r -&gt; r[2] ==  11, transform = Rot) |&gt;
    attach(glead, region = r -&gt; r[2] == -11, reverse = true, transform = Rot) |&gt;
    greenfunction
GreenFunction{Float64,2,0}: Green function of a Hamiltonian{Float64,2,0}
  Solver          : AppliedSparseLUGreenSolver
  Contacts        : 4
  Contact solvers : (SelfEnergySchurSolver, SelfEnergySchurSolver, SelfEnergySchurSolver, SelfEnergySchurSolver)
  Contact sizes   : (5, 5, 5, 5)
  Hamiltonian{Float64,2,0}: Hamiltonian on a 0D Lattice in 2D space
    Bloch harmonics  : 1
    Harmonic size    : 353 × 353
    Orbitals         : [1]
    Element type     : scalar (ComplexF64)
    Onsites          : 0
    Hoppings         : 1320
    Coordination     : 3.73938

julia&gt; qplot(g, children = (; selector = siteselector(; cells = 1:5), sitecolor = :blue))</code></pre><img src="../../assets/multiterminal.png" alt="Multiterminal system" width="300" class="center"/><p>Note that since we did not specify the <code>solver</code> in <code>greenfunction</code>, the <code>L=0</code> default <code>GS.SparseLU()</code> was taken.</p><p>We can also visualize <code>glead</code>, which is defined on a 1D lattice with a boundary. Boundary cells are shown by default in red</p><div class="admonition is-success"><header class="admonition-header">The GreenFunction &lt;-&gt; AbstractHamiltonian relation</header><div class="admonition-body"><p>Its important un appreciate that a <code>g::GreenFunction</code> represents the retarded Green function between sites in a given <code>AbstractHamiltonian</code>, but not on sites of the coupled <code>AbstractHamiltonians</code> of its attached self-energies. Therefore, <code>gcentral</code> above cannot yield observables in the leads (blue sites above), only on the red sites. To obtain observables in a given lead, its <code>GreenFunction</code> must be constructed, with an attached self-energy coming from the central region plus the other three leads.</p></div></div><h2 id="Slicing-and-evaluation"><a class="docs-heading-anchor" href="#Slicing-and-evaluation">Slicing and evaluation</a><a id="Slicing-and-evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Slicing-and-evaluation" title="Permalink"></a></h2><p>As explained above, a <code>g::GreenFunction</code> represents a Green function of an <code>OpenHamiltonian</code> (i.e. <code>AbstractHamiltonian</code> with zero or more self-energies), but it does so for any energy <code>ω</code> or lattice sites.</p><pre><code class="nohighlight hljs">- To specify `ω` (plus any parameters `params` in the underlying `AbstractHamiltonian`) we use the syntax `g(ω; params...)`, which yields an `gω::GreenSolution`
- To specify source (`sⱼ`) and drain (`sᵢ`) sites we use the syntax `g[sᵢ, sⱼ]` or `g[sᵢ] == g[sᵢ,sᵢ]`, which yields a `gs::GreenSlice`. `sᵢ` and `sⱼ` can be `SiteSelectors(; sites...)`, or an integer denoting a specific contact (i.e. sites with an attached self-energy) or `:` denoting all contacts merged together.
- If we specify both of the above we get the Green function between the orbitals of the specified sites at the specified energy, in the form of an `OrbitalSliceMatrix`, which is a special `AbstractMatrix` that knows about the orbitals in the lattice over which its matrix elements are defined.</code></pre><p>Let us see this in action using the example from the previous section</p><pre><code class="language-julia hljs">julia&gt; g[1, 3]
GreenSlice{Float64,2,0}: Green function at arbitrary energy, but at a fixed lattice positions

julia&gt; g(0.2)
GreenSolution{Float64,2,0}: Green function at arbitrary positions, but at a fixed energy

julia&gt; g(0.2)[1, 3]
5×5 OrbitalSliceArray{ComplexF64,Array}:
 -2.56906+0.000123273im  -4.28767+0.00020578im   -4.88512+0.000234514im  -4.28534+0.00020578im    -2.5664+0.000123273im
 -4.28767+0.00020578im   -7.15613+0.00034351im   -8.15346+0.000391475im  -7.15257+0.00034351im    -4.2836+0.000205781im
 -4.88512+0.000234514im  -8.15346+0.000391475im  -9.29002+0.000446138im  -8.14982+0.000391476im  -4.88095+0.000234514im
 -4.28534+0.00020578im   -7.15257+0.00034351im   -8.14982+0.000391476im  -7.14974+0.000343511im  -4.28211+0.000205781im
  -2.5664+0.000123273im   -4.2836+0.000205781im  -4.88095+0.000234514im  -4.28211+0.000205781im  -2.56469+0.000123273im

julia&gt; g(0.2)[siteselector(region = RP.circle(1, (0.5, 0))), 3]
2×5 OrbitalSliceArray{ComplexF64,Array}:
 0.0749214+3.15744e-8im   0.124325+5.27948e-8im   0.141366+6.01987e-8im   0.124325+5.27948e-8im  0.0749214+3.15744e-8im
 -0.374862+2.15287e-5im  -0.625946+3.5938e-5im   -0.712983+4.09561e-5im  -0.624747+3.59379e-5im   -0.37348+2.15285e-5im</code></pre><div class="admonition is-success"><header class="admonition-header">Fixing parameters</header><div class="admonition-body"><p>In the same way we can fix all parameters of a <code>h::ParametricHamiltonian</code> with <code>h´=h(;params...)</code> (which produces a <code>h´::Hamiltonian</code> without any parametric dependencies), we can similarly fix all parameters in a <code>g::GreenFunction</code> (or <code>g::GreenSlice</code>) with <code>g(; params...)</code>, which produces a new <code>GreenFunction</code> (or <code>GreenSlice</code>). Note that, like in the case of <code>h</code>, this fixes <em>all</em> parameters. Any parameter that is not specify will be fixed to its default value.</p></div></div><h3 id="Diagonal-slices"><a class="docs-heading-anchor" href="#Diagonal-slices">Diagonal slices</a><a id="Diagonal-slices-1"></a><a class="docs-heading-anchor-permalink" href="#Diagonal-slices" title="Permalink"></a></h3><p>There is a special form of slicing that requests just the diagonal of a given <code>g[sᵢ] == g[sᵢ,sᵢ]</code>. It uses the syntax <code>g[diagonal(sᵢ)]</code>. Let us see it in action in a multiorbital example in 2D</p><pre><code class="language-julia hljs">julia&gt; g = HP.graphene(a0 = 1, t0 = 1, orbitals = 2) |&gt; greenfunction
GreenFunction{Float64,2,2}: Green function of a Hamiltonian{Float64,2,2}
  Solver          : AppliedBandsGreenSolver
  Contacts        : 0
  Contact solvers : ()
  Contact sizes   : ()
  Hamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space
    Bloch harmonics  : 5
    Harmonic size    : 2 × 2
    Orbitals         : [2, 2]
    Element type     : 2 × 2 blocks (ComplexF64)
    Onsites          : 0
    Hoppings         : 6
    Coordination     : 3.0

julia&gt; g(0.5)[diagonal(cells = (0, 0))]
4×4 OrbitalSliceMatrix{ComplexF64,LinearAlgebra.Diagonal{ComplexF64, Vector{ComplexF64}}}:
 -0.349736-0.311836im        0.0+0.0im             0.0+0.0im             0.0+0.0im
       0.0+0.0im       -0.349736-0.311836im        0.0+0.0im             0.0+0.0im
       0.0+0.0im             0.0+0.0im       -0.349736-0.311836im        0.0+0.0im
       0.0+0.0im             0.0+0.0im             0.0+0.0im       -0.349736-0.311836im</code></pre><p>Note that we get an <code>OrbitalSliceVector</code>, which is equal to the diagonal <code>diag(g(0.5)[cells = (0, 0)])</code>. Like the <code>g</code> <code>OrbitalSliceMatrix</code>, this vector is resolved in orbitals, of which there are two per site and four per unit cell in this case. Using <code>diagonal(sᵢ; kernel = K)</code> we can collect all the orbitals of different sites, and compute <code>tr(g[site, site] * K)</code> for a given matrix <code>K</code>. This is useful to obtain spectral densities. In the above example, and interpreting the two orbitals per site as the electron spin, we could obtain the spin density along the <code>x</code> axis, say, using <code>σx = SA[0 1; 1 0]</code> as <code>kernel</code>,</p><pre><code class="language-julia hljs">julia&gt; g(0.5)[diagonal(cells = (0, 0), kernel = SA[0 1; 1 0])]
2×2 OrbitalSliceMatrix{ComplexF64,LinearAlgebra.Diagonal{ComplexF64, Vector{ComplexF64}}}:
 -2.57031e-12-2.62859e-17im          0.0+0.0im
          0.0+0.0im          2.57031e-12+2.27291e-17im</code></pre><p>which is zero in this spin-degenerate case</p><div class="admonition is-success"><header class="admonition-header">Slicing `OrbitalSliceArray`s</header><div class="admonition-body"><p>An <code>v::OrbitalSliceVector</code> and <code>m::OrbitalSliceMatrix</code> are both <code>a::OrbitalSliceArray</code>, and wrap conventional arrays, with e.g. conventional <code>axes</code>. They also provide, however, <code>orbaxes(a)</code>, which are a tuple of <code>OrbitalSliceGrouped</code>. These are <code>LatticeSlice</code>s that represent orbitals grouped by sites. They allow an interesting additional functionality. You can index <code>v[sitelector(...)]</code> or <code>m[rowsiteselector, colsiteselector]</code> to obtain a new <code>OrbitalSliceArray</code> of the selected rows and cols. The full machinery of <code>siteselector</code> applies. One can also use a lower-level <code>v[sites(cell_index, site_indices)]</code> to obtain an unwrapped <code>AbstractArray</code>, without building new <code>orbaxes</code>. See <code>OrbitalSliceArray</code> for further details.</p></div></div><h2 id="Visualizing-a-Green-function"><a class="docs-heading-anchor" href="#Visualizing-a-Green-function">Visualizing a Green function</a><a id="Visualizing-a-Green-function-1"></a><a class="docs-heading-anchor-permalink" href="#Visualizing-a-Green-function" title="Permalink"></a></h2><p>We can use <code>qplot</code> to visualize a <code>GreenSolution</code> in space. Here we define a bounded square lattice with an interesting shape, and attach a model self-energy to the right. Then we compute the Green function from each orbital in the contact to any other site in the lattice, and compute the norm over contact sites. The resulting vector is used as a shader for the color and radius of sites when plotting the system</p><pre><code class="language-julia hljs">julia&gt; h = LP.square() |&gt; onsite(4) - hopping(1) |&gt; supercell(region = r -&gt; norm(r) &lt; 40*(1+0.2*cos(5*atan(r[2],r[1]))));

julia&gt; g = h |&gt; attach(@onsite(ω -&gt; -im), region = r -&gt; r[1] ≈ 47) |&gt; greenfunction;

julia&gt; gx1 = sum(abs2, g(0.1)[siteselector(), 1], dims = 2);

julia&gt; qplot(h, hide = :hops, sitecolor = (i, r) -&gt; gx1[i], siteradius = (i, r) -&gt; gx1[i], minmaxsiteradius = (0, 2), sitecolormap = :balance)</code></pre><img src="../../assets/star_shape.png" alt="Green function from a contact on the right" width="400" class="center"/><div class="admonition is-warning"><header class="admonition-header">Caveat for multiorbital systems</header><div class="admonition-body"><p>Since, currently, <code>g(ω)[sᵢ, sⱼ]</code> yields a <code>Matrix</code> over orbitals (instead of over sites), the above example requires single-orbital sites to work. In the future we will probably introduce a way to slice a <code>GreenSolution</code> over sites, similar to the way <code>diagonal</code> works. For the moment, one can use observables like <code>ldos</code> for visualization (see next section), which are all site-based by default.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../bandstructures/">« Bandstructures</a><a class="docs-footer-nextpage" href="../observables/">Observables »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 30 January 2025 16:49">Thursday 30 January 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
