<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Hamiltonians · Quantica.jl</title><meta name="title" content="Hamiltonians · Quantica.jl"/><meta property="og:title" content="Hamiltonians · Quantica.jl"/><meta property="twitter:title" content="Hamiltonians · Quantica.jl"/><meta name="description" content="Documentation for Quantica.jl."/><meta property="og:description" content="Documentation for Quantica.jl."/><meta property="twitter:description" content="Documentation for Quantica.jl."/><meta property="og:url" content="https://pablosanjose.github.io/Quantica.jl/tutorial/hamiltonians/"/><meta property="twitter:url" content="https://pablosanjose.github.io/Quantica.jl/tutorial/hamiltonians/"/><link rel="canonical" href="https://pablosanjose.github.io/Quantica.jl/tutorial/hamiltonians/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Quantica.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Quantica.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Quantica.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../tutorial/">Welcome</a></li><li><a class="tocitem" href="../glossary/">Glossary</a></li><li><a class="tocitem" href="../lattices/">Lattices</a></li><li><a class="tocitem" href="../models/">Models</a></li><li class="is-active"><a class="tocitem" href>Hamiltonians</a><ul class="internal"><li><a class="tocitem" href="#A-more-elaborate-example:-the-Kane-Mele-model"><span>A more elaborate example: the Kane-Mele model</span></a></li><li><a class="tocitem" href="#ParametricHamiltonians"><span>ParametricHamiltonians</span></a></li><li><a class="tocitem" href="#Obtaining-actual-matrices"><span>Obtaining actual matrices</span></a></li><li><a class="tocitem" href="#Transforming-Hamiltonians"><span>Transforming Hamiltonians</span></a></li><li><a class="tocitem" href="#Combining-Hamiltonians"><span>Combining Hamiltonians</span></a></li></ul></li><li><a class="tocitem" href="../bandstructures/">Bandstructures</a></li><li><a class="tocitem" href="../greenfunctions/">GreenFunctions</a></li><li><a class="tocitem" href="../observables/">Observables</a></li></ul></li><li><span class="tocitem">Advanced</span><ul><li><a class="tocitem" href="../../advanced/nonspatial/">Non-spatial models</a></li><li><a class="tocitem" href="../../advanced/serializers/">Serializers</a></li><li><a class="tocitem" href="../../advanced/meanfield/">Self-consistent mean fields</a></li><li><a class="tocitem" href="../../advanced/wannier90/">Wannier90 imports</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>Hamiltonians</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Hamiltonians</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/pablosanjose/Quantica.jl/blob/master/docs/src/tutorial/hamiltonians.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Hamiltonians"><a class="docs-heading-anchor" href="#Hamiltonians">Hamiltonians</a><a id="Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonians" title="Permalink"></a></h1><p>We build a Hamiltonian by combining a <code>Lattice</code> and a <code>TightbindingModel</code>, optionally specifying also the number of orbitals on each sublattice if there is more than one. A spinful graphene model (two orbitals per site in both sublattices) with nearest neighbor hopping <code>t0 = 2.7</code> would be written as</p><pre><code class="language-julia hljs">julia&gt; lat = LP.honeycomb(); model = hopping(2.7*I);

julia&gt; h = hamiltonian(lat, model; orbitals = 2)
Hamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5
  Harmonic size    : 2 × 2
  Orbitals         : [2, 2]
  Element type     : 2 × 2 blocks (ComplexF64)
  Onsites          : 0
  Hoppings         : 6
  Coordination     : 3.0</code></pre><p>A crucial thing to remember when defining multi-orbital Hamiltonians as the above is that <code>onsite</code> and <code>hopping</code> amplitudes need to be matrices of the correct size. The symbol <code>I</code> in Julia represents the identity matrix of any size, which is convenient to define a spin-preserving hopping in the case above. An alternative would be to use <code>model = hopping(2.7*SA[1 0; 0 1])</code>.</p><div class="admonition is-success" id="Models-with-different-number-of-orbitals-per-sublattice-60b17b22724efd01"><header class="admonition-header">Models with different number of orbitals per sublattice<a class="admonition-anchor" href="#Models-with-different-number-of-orbitals-per-sublattice-60b17b22724efd01" title="Permalink"></a></header><div class="admonition-body"><p>Non-homogeneous multiorbital models are more advanced but are fully supported in Quantica.jl. Just use <code>orbitals = (n₁, n₂,...)</code> to have <code>nᵢ</code> orbitals in sublattice <code>i</code>, and make sure your model is consistent with that. As in the case of the <code>dim</code> keyword in <code>lattice</code>, you can also use <code>Val(nᵢ)</code> for marginally faster construction.</p></div></div><p>Similarly to <code>LatticePreset</code>s, we also have <code>HamiltonianPresets</code>, also aliased as <code>HP</code>. Currently, we have only <code>HP.graphene(...)</code> and <code>HP.twisted_bilayer_graphene(...)</code>, but we expect to extend this library in the future (see the docstring of <code>HP</code>).</p><h2 id="A-more-elaborate-example:-the-Kane-Mele-model"><a class="docs-heading-anchor" href="#A-more-elaborate-example:-the-Kane-Mele-model">A more elaborate example: the Kane-Mele model</a><a id="A-more-elaborate-example:-the-Kane-Mele-model-1"></a><a class="docs-heading-anchor-permalink" href="#A-more-elaborate-example:-the-Kane-Mele-model" title="Permalink"></a></h2><p>The Kane-Mele model for graphene describes intrinsic spin-orbit coupling (SOC), in the form of an imaginary second-nearest-neighbor hopping between same-sublattice sites, with a sign that alternates depending on hop direction <code>dr</code>. A possible implementation in Quantica.jl would be</p><pre><code class="language-julia hljs">SOC(dr) = 0.05 * ifelse(iseven(round(Int, atan(dr[2], dr[1])/(pi/3))), im, -im)

model =
  hopping(1, range = neighbors(1)) +
  hopping((r, dr) -&gt;  SOC(dr); sublats = :A =&gt; :A, range = neighbors(2)) +
  hopping((r, dr) -&gt; -SOC(dr); sublats = :B =&gt; :B, range = neighbors(2))

h = LatticePresets.honeycomb() |&gt; model

qplot(h)</code></pre><img src="../../assets/latticeKM.png" alt="Kane-Mele lattice" width="350" class="center"/><p>Interactive tooltips in the visualization of <code>h</code> are enabled by default (use keyword <code>inspector = false</code> to disable them). They allows to navigate each <code>onsite</code> and <code>hopping</code> amplitude graphically. Note that sites connected to the unit cell of <code>h</code> by some hopping are included, but are rendered with partial transparency by default.</p><h2 id="ParametricHamiltonians"><a class="docs-heading-anchor" href="#ParametricHamiltonians">ParametricHamiltonians</a><a id="ParametricHamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#ParametricHamiltonians" title="Permalink"></a></h2><p>If we use a <code>ParametricModel</code> instead of a simple <code>TightBindingModel</code> we will obtain a <code>ParametricHamiltonian</code> instead of a simple <code>Hamiltonian</code>, both of which are subtypes of the <code>AbstractHamiltonian</code> type</p><pre><code class="language-julia hljs">julia&gt; model_param = @hopping((; t = 2.7) -&gt; t*I);

julia&gt; h_param = hamiltonian(lat, model_param; orbitals = 2)
ParametricHamiltonian{Float64,2,2}: Parametric Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5
  Harmonic size    : 2 × 2
  Orbitals         : [2, 2]
  Element type     : 2 × 2 blocks (ComplexF64)
  Onsites          : 0
  Hoppings         : 6
  Coordination     : 3.0
  Parameters       : [:t]</code></pre><p>We can also apply <code>Modifier</code>s by passing them as extra arguments to <code>hamiltonian</code>, which results again in a <code>ParametricHamiltonian</code> with the parametric modifiers applied</p><pre><code class="language-julia hljs">julia&gt; peierls! = @hopping!((t, r, dr; Bz = 0) -&gt; t * cis(-Bz/2 * SA[-r[2], r[1]]&#39; * dr));

julia&gt; h_param_mod = hamiltonian(lat, model_param, peierls!; orbitals = 2)
ParametricHamiltonian{Float64,2,2}: Parametric Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5
  Harmonic size    : 2 × 2
  Orbitals         : [2, 2]
  Element type     : 2 × 2 blocks (ComplexF64)
  Onsites          : 0
  Hoppings         : 6
  Coordination     : 3.0
  Parameters       : [:Bz, :t]</code></pre><p>Note that <code>SA[-r[2], r[1]]</code> above is a 2D <code>SVector</code>, because since the embedding dimension is <code>E = 2</code>, both <code>r</code> and <code>dr</code> are also 2D <code>SVector</code>s.</p><p>We can also apply modifiers to an already constructed <code>AbstractHamiltonian</code>. The following is equivalent to the above</p><pre><code class="language-julia hljs">julia&gt; h_param_mod = hamiltonian(h_param, peierls!);</code></pre><div class="admonition is-warning" id="Modifiers-do-not-commute-3f527c1f8938dcd8"><header class="admonition-header">Modifiers do not commute<a class="admonition-anchor" href="#Modifiers-do-not-commute-3f527c1f8938dcd8" title="Permalink"></a></header><div class="admonition-body"><p>We can add as many modifiers as we need by passing them as extra arguments to <code>hamiltonian</code>, and they will be applied sequentially, one by one. Beware, however, that modifiers do not necessarily commute, in the sense that the result will in general depend on their order.</p></div></div><p>We can obtain a plain <code>Hamiltonian</code> from a <code>ParametricHamiltonian</code> by applying specific values to its parameters. To do so, simply use the call syntax with parameters as keyword arguments</p><pre><code class="language-julia hljs">julia&gt; h_param_mod(Bz = 0.1, t = 1)
Hamiltonian{Float64,2,2}: Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5
  Harmonic size    : 2 × 2
  Orbitals         : [2, 2]
  Element type     : 2 × 2 blocks (ComplexF64)
  Onsites          : 0
  Hoppings         : 6
  Coordination     : 3.0</code></pre><div class="admonition is-success" id="Syntax-lat-model-and-h-modifier-58d6619c5324af5c"><header class="admonition-header">Syntax `lat |&gt; model` and `h |&gt; modifier<a class="admonition-anchor" href="#Syntax-lat-model-and-h-modifier-58d6619c5324af5c" title="Permalink"></a></header><div class="admonition-body"><p>The common cases <code>lat |&gt; hamiltonian(model)</code> (or <code>hamiltonian(lat, model)</code>) and <code>h |&gt; hamiltonian(modifier)</code> (or <code>hamiltonian(h, modifier)</code>) can be also written as <code>lat |&gt; model</code> and <code>h |&gt; modifier</code>, respectively. Hence <code>hamiltonian(lat, model, modifier)</code> may be written as <code>lat |&gt; model |&gt; modifier</code>. This form however does not allow to specify the number of orbitals per sublattice (it will be one, the default).</p></div></div><h2 id="Obtaining-actual-matrices"><a class="docs-heading-anchor" href="#Obtaining-actual-matrices">Obtaining actual matrices</a><a id="Obtaining-actual-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Obtaining-actual-matrices" title="Permalink"></a></h2><p>For an L-dimensional <code>h::AbstractHamiltonian</code> (i.e. defined on a Lattice with <code>L</code> Bravais vectors), the Hamiltonian matrix between any unit cell with cell index <code>n</code> and another unit cell at <code>n+dn</code> (here known as a Hamiltonian &quot;harmonic&quot;) is given by <code>h[dn]</code></p><pre><code class="language-julia hljs">julia&gt; h[(1,0)]
4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:
     ⋅          ⋅      2.7+0.0im  0.0+0.0im
     ⋅          ⋅      0.0+0.0im  2.7+0.0im
     ⋅          ⋅          ⋅          ⋅
     ⋅          ⋅          ⋅          ⋅

julia&gt; h[(0,0)]
4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:
     ⋅          ⋅      2.7+0.0im  0.0+0.0im
     ⋅          ⋅      0.0+0.0im  2.7+0.0im
 2.7+0.0im  0.0+0.0im      ⋅          ⋅
 0.0+0.0im  2.7+0.0im      ⋅          ⋅</code></pre><div class="admonition is-success" id="Cell-distance-indices-79374f30ce2fb73b"><header class="admonition-header">Cell distance indices<a class="admonition-anchor" href="#Cell-distance-indices-79374f30ce2fb73b" title="Permalink"></a></header><div class="admonition-body"><p>We can use <code>Tuple</code>s or <code>SVector</code>s for cell distance indices <code>dn</code>. An empty <code>Tuple</code> <code>dn = ()</code> will always return the main intra-unitcell harmonic: <code>h[()] = h[(0,0...)] = h[SA[0,0...]]</code>.</p></div></div><div class="admonition is-info" id="Bounded-Hamiltonians-85c4cec200d83df"><header class="admonition-header">Bounded Hamiltonians<a class="admonition-anchor" href="#Bounded-Hamiltonians-85c4cec200d83df" title="Permalink"></a></header><div class="admonition-body"><p>If the Hamiltonian has a bounded lattice (i.e. it has <code>L=0</code> Bravais vectors), we will simply use an empty tuple to obtain its matrix <code>h[()]</code>. This is not in conflict with the above syntax.</p></div></div><p>Note that if <code>h</code> is a <code>ParametricHamiltonian</code>, such as <code>h_param</code> above, we will get zeros in place of the unspecified parametric terms, unless we actually first specify the values of the parameters</p><pre><code class="language-julia hljs">julia&gt; h_param[(0,0)] # Parameter t is not specified -&gt; it is not applied
4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:
     ⋅          ⋅      0.0+0.0im  0.0+0.0im
     ⋅          ⋅      0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im      ⋅          ⋅
 0.0+0.0im  0.0+0.0im      ⋅          ⋅

julia&gt; h_param(t=2)[(0,0)]
4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:
     ⋅          ⋅      2.0+0.0im  0.0+0.0im
     ⋅          ⋅      0.0+0.0im  2.0+0.0im
 2.0+0.0im  0.0+0.0im      ⋅          ⋅
 0.0+0.0im  2.0+0.0im      ⋅          ⋅</code></pre><div class="admonition is-info" id="ParametricHamiltonian-harmonics-b8da5d5f6bf1946a"><header class="admonition-header">ParametricHamiltonian harmonics<a class="admonition-anchor" href="#ParametricHamiltonian-harmonics-b8da5d5f6bf1946a" title="Permalink"></a></header><div class="admonition-body"><p>The above behavior for unspecified parameters is not set in stone and may change in future versions. Another option would be to apply their default values (which may, however, not exist).</p></div></div><p>We are usually not interested in the harmonics <code>h[dn]</code> themselves, but rather in the Bloch matrix of a Hamiltonian</p><p><span>$H(\phi) = \sum_{dn} H_{dn} \exp(-i \phi * dn)$</span></p><p>where <span>$H_{dn}$</span> are the Hamiltonian harmonics, <span>$\phi = (\phi_1, \phi_2...) = (k\cdot A_1, k\cdot A_2...)$</span> are the Bloch phases, <span>$k$</span> is the Bloch wavevector and <span>$A_i$</span> are the Bravais vectors.</p><p>We obtain the Bloch matrix using the syntax <code>h(ϕ; params...)</code></p><pre><code class="language-julia hljs">julia&gt; h((0,0))
4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:
     ⋅          ⋅      8.1+0.0im  0.0+0.0im
     ⋅          ⋅      0.0+0.0im  8.1+0.0im
 8.1+0.0im  0.0+0.0im      ⋅          ⋅
 0.0+0.0im  8.1+0.0im      ⋅          ⋅

julia&gt; h_param_mod((0.2, 0.3); B = 0.1)
4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 8 stored entries:
         ⋅                  ⋅          7.92559-1.33431im      0.0+0.0im
         ⋅                  ⋅              0.0+0.0im      7.92559-1.33431im
 7.92559+1.33431im      0.0+0.0im              ⋅                  ⋅
     0.0+0.0im      7.92559+1.33431im          ⋅                  ⋅</code></pre><p>Note that unspecified parameters take their default values when using the call syntax (as per the standard Julia convention). Any unspecified parameter that does not have a default value will produce an <code>UndefKeywordError</code> error.</p><h2 id="Transforming-Hamiltonians"><a class="docs-heading-anchor" href="#Transforming-Hamiltonians">Transforming Hamiltonians</a><a id="Transforming-Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#Transforming-Hamiltonians" title="Permalink"></a></h2><p>Like with lattices, we can transform an <code>h::AbstractHamiltonians</code> using <code>supercell</code>, <code>reverse</code>, <code>transform</code> and <code>translate</code>. All these except <code>supercell</code> operate only on the underlying <code>lattice(h)</code> of <code>h</code>, leaving the hoppings and onsite elements unchanged. Meanwhile, <code>supercell</code> acts on <code>lattice(h)</code> but also copies the hoppings and onsites of <code>h</code> onto the new sites, preserving the periodicity of the original <code>h</code>.</p><p>Additionally, we can also use <code>stitch</code> and <code>@stitch</code>, which makes the <code>h</code> lattice periodic along some (or all) of its Bravais vectors, while leaving the rest unbounded.</p><pre><code class="language-julia hljs">julia&gt; stitch(HP.graphene(), (0, :))
Hamiltonian{Float64,2,1}: Hamiltonian on a 1D Lattice in 2D space
  Bloch harmonics  : 3
  Harmonic size    : 2 × 2
  Orbitals         : [1, 1]
  Element type     : scalar (ComplexF64)
  Onsites          : 0
  Hoppings         : 4
  Coordination     : 2.0</code></pre><p>The <code>phases</code> argument of <code>stitch(h, phases)</code> is a <code>Tuple</code> of real numbers and/or colons (<code>:</code>), of length equal to the lattice dimension of <code>h</code>. Each real number <code>ϕᵢ</code> corresponds to a Bravais vector along which the transformed lattice will become periodic, picking up a phase <code>exp(iϕᵢ)</code> in the new hoppings, while each colon leaves the lattice unbounded along the corresponding Bravais vector. (Check the <code>stitch</code> and <code>@stitch</code> docstrings for additional syntax and functionality.) In a way, <code>stitch</code> is the dual to <code>supercell</code>, in that it applies a different boundary condition to the lattice along the eliminated Bravais vectors, periodic instead of open, as in the case of <code>supercell</code>. The phases <code>ϕᵢ</code> are also connected to Bloch phases, in the sense that e.g. <code>stitch(h, (ϕ₁, :))(; ϕ₂) == h(ϕ₁, ϕ₂)</code>.</p><p>It&#39;s important to understand that, when transforming an <code>h::AbstractHamiltonian</code>, the model used to build <code>h</code> is not re-evaluated. Hoppings and onsite energies are merely copied so as to preserve the periodicity of the original <code>h</code>. As a consequence, these two constructions give different Hamiltonians</p><pre><code class="language-julia hljs">julia&gt; h1 = LP.linear() |&gt; supercell(4) |&gt; hamiltonian(onsite(r -&gt; r[1]));

julia&gt; h2 = LP.linear() |&gt; hamiltonian(onsite(r -&gt; r[1])) |&gt; supercell(4);</code></pre><p>In the case of <code>h1</code> the <code>onsite</code> model is applied to the 4-site unitcell. Since each site has a different position, each gets a different onsite energy.</p><pre><code class="language-julia hljs">julia&gt; h1[()]
4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:
 0.0+0.0im      ⋅          ⋅          ⋅
     ⋅      1.0+0.0im      ⋅          ⋅
     ⋅          ⋅      2.0+0.0im      ⋅
     ⋅          ⋅          ⋅      3.0+0.0im</code></pre><p>In contrast <code>h2</code> first gets the <code>onsite</code> model applied with a 1-site unitcell at position <code>r = SA[0]</code>, so all sites in the lattice get onsite energy zero. Only then it is expanded with <code>supercell</code>, which generates a 4-site unitcell with zero onsite energy on all its sites</p><pre><code class="language-julia hljs">julia&gt; h2[()]
4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:
 0.0+0.0im      ⋅          ⋅          ⋅
     ⋅      0.0+0.0im      ⋅          ⋅
     ⋅          ⋅      0.0+0.0im      ⋅
     ⋅          ⋅          ⋅      0.0+0.0im</code></pre><p>As a consequence, <code>h</code> and <code>supercell(h)</code> represent exactly the same system, with the same observables, but with a different choice of unitcell.</p><p>These two different behaviors make sense in different situations, so it is important to be aware of the order dependence of transformations. Similar considerations apply to <code>transform</code>, <code>translate</code> and <code>stitch</code> when models are position dependent.</p><h2 id="Combining-Hamiltonians"><a class="docs-heading-anchor" href="#Combining-Hamiltonians">Combining Hamiltonians</a><a id="Combining-Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#Combining-Hamiltonians" title="Permalink"></a></h2><p>Multiple <code>h::AbstractHamiltonian</code>s (or multiple <code>l::Lattice</code>s) can be combined into one with <code>combine</code>.</p><pre><code class="language-julia hljs">julia&gt; h1 = LP.linear(dim = 2) |&gt; hopping(1); h2 = LP.linear(dim = 2, names = :B) |&gt; hopping(1) |&gt; translate(SA[0,1]) |&gt; @onsite!((o; p=1) -&gt; o+p);

julia&gt; combine(h1, h2; coupling = hopping(2))
ParametricHamiltonian{Float64,2,1}: Parametric Hamiltonian on a 1D Lattice in 2D space
  Bloch harmonics  : 3
  Harmonic size    : 2 × 2
  Orbitals         : [1, 1]
  Element type     : scalar (ComplexF64)
  Onsites          : 0
  Hoppings         : 6
  Coordination     : 3.0
  Parameters       : [:p]</code></pre><p>The <code>coupling</code> keyword, available when combining <code>h::AbstractHamiltonian</code>s, is a hopping model that is applied between each <code>h</code>. It can be constrained as usual with <code>hopselector</code>s and also be parametric. If either <code>coupling</code> or any of the combined <code>h</code> is parametric, the result of <code>combine</code> will be a <code>ParametricHamiltonian</code>, or a <code>Hamiltonian</code> otherwise.</p><p>The objects to be combined must satisfy some conditions:</p><ul><li>They must have the same Bravais vectors (modulo reorderings), which will be then inherited by the combined object.</li><li>They must have the same position type (the <code>T</code> in <code>AbstractHamiltonian{T}</code> and <code>Lattice{T}</code>)</li><li>They must have no repeated sublattice names among them (unless the combined object is non-parametric)</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../models/">« Models</a><a class="docs-footer-nextpage" href="../bandstructures/">Bandstructures »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 1 October 2025 14:34">Wednesday 1 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
