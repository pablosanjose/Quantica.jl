<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Bandstructures · Quantica.jl</title><meta name="title" content="Bandstructures · Quantica.jl"/><meta property="og:title" content="Bandstructures · Quantica.jl"/><meta property="twitter:title" content="Bandstructures · Quantica.jl"/><meta name="description" content="Documentation for Quantica.jl."/><meta property="og:description" content="Documentation for Quantica.jl."/><meta property="twitter:description" content="Documentation for Quantica.jl."/><meta property="og:url" content="https://pablosanjose.github.io/Quantica.jl/tutorial/bandstructures/"/><meta property="twitter:url" content="https://pablosanjose.github.io/Quantica.jl/tutorial/bandstructures/"/><link rel="canonical" href="https://pablosanjose.github.io/Quantica.jl/tutorial/bandstructures/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Quantica.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Quantica.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Quantica.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../tutorial/">Welcome</a></li><li><a class="tocitem" href="../glossary/">Glossary</a></li><li><a class="tocitem" href="../lattices/">Lattices</a></li><li><a class="tocitem" href="../models/">Models</a></li><li><a class="tocitem" href="../hamiltonians/">Hamiltonians</a></li><li class="is-active"><a class="tocitem" href>Bandstructures</a><ul class="internal"><li><a class="tocitem" href="#Band-defects"><span>Band defects</span></a></li><li><a class="tocitem" href="#Coordinate-mapping-and-band-linecuts"><span>Coordinate mapping and band linecuts</span></a></li><li><a class="tocitem" href="#Band-indexing-and-slicing"><span>Band indexing and slicing</span></a></li></ul></li><li><a class="tocitem" href="../greenfunctions/">GreenFunctions</a></li><li><a class="tocitem" href="../observables/">Observables</a></li></ul></li><li><span class="tocitem">Advanced</span><ul><li><a class="tocitem" href="../../advanced/nonspatial/">Non-spatial models</a></li><li><a class="tocitem" href="../../advanced/serializers/">Serializers</a></li><li><a class="tocitem" href="../../advanced/meanfield/">Self-consistent mean fields</a></li><li><a class="tocitem" href="../../advanced/wannier90/">Wannier90 imports</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>Bandstructures</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Bandstructures</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/pablosanjose/Quantica.jl/blob/master/docs/src/tutorial/bandstructures.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Bandstructures"><a class="docs-heading-anchor" href="#Bandstructures">Bandstructures</a><a id="Bandstructures-1"></a><a class="docs-heading-anchor-permalink" href="#Bandstructures" title="Permalink"></a></h1><p>The eigenpairs (eigenvalues and eigenvectors) of a <code>Hamiltonian</code> or <code>ParametricHamiltonian</code> at given Bloch phases <code>ϕᵢ</code> can be obtained with <code>spectrum</code>:</p><pre><code class="language-julia hljs">julia&gt; h = LP.honeycomb() |&gt; hopping(1); ϕᵢ = (0, π);

julia&gt; eᵢ, ψᵢ = spectrum(h, ϕᵢ; solver = EigenSolvers.LinearAlgebra())
Spectrum{Float64,ComplexF64} :
Energies:
2-element Vector{ComplexF64}:
 -1.0 + 0.0im
  1.0 + 0.0im
States:
2×2 Matrix{ComplexF64}:
  0.707107-8.65956e-17im  0.707107-8.65956e-17im
 -0.707107+0.0im          0.707107+0.0im</code></pre><p>The above destructuring syntax assigns eigenvalues and eigenvectors to <code>eᵢ</code> and <code>ψᵢ</code>, respectively. The available eigensolvers and their options can be checked in the <code>EigenSolvers</code> docstrings. They are supported through the extension mechanism in Julia, so they require additional libraries to be loaded first, such as <code>using Arpack</code> or <code>using ArnoldiMethod</code>.</p><div class="admonition is-warning"><header class="admonition-header">Arpack solver is not thread-safe</header><div class="admonition-body"><p><code>EigenSolvers.Arpack</code> relies on a Fortran library that is not currently thread-safe. If you launch Julia with multiple threads, they will not be used with this specific solver. Otherwise Arpack would segfault.</p></div></div><p>We define a &quot;bandstructure&quot; of an <code>h::AbstractHamiltonian</code> as a linear interpolation of its eigenpairs over a portion of the Brillouin zone, which is discretized with a base mesh of <code>ϕᵢ</code> values. At each <code>ϕᵢ</code> of the base mesh, the Bloch matrix <code>h(ϕᵢ)</code> is diagonalized with <code>spectrum</code>. The adjacent eigenpairs <code>eⱼ(ϕᵢ), ψⱼ(ϕᵢ)</code> are then connected (&quot;stitched&quot;) together into a number of band meshes with vertices <code>(ϕᵢ..., eⱼ(ϕᵢ))</code> by maximizing the overlap of adjacent <code>ψⱼ(ϕᵢ)</code> (since the bands should be continuuous). Degenerate eigenpairs are collected into a single node of the band mesh.</p><p>The bandstructure of an <code>h::AbstractHamiltonian</code> is computed using <code>bands</code>:</p><pre><code class="language-julia hljs">julia&gt; ϕ₁points = ϕ₂points = range(0, 2π, length = 19);

julia&gt; b = bands(h, ϕ₁points, ϕ₂points)
Bandstructure{Float64,3,2}: 3D Bandstructure over a 2-dimensional parameter space of type Float64
  Subbands  : 1
  Vertices  : 720
  Edges     : 2016
  Simplices : 1296</code></pre><p>The first argument is the <code>AbstractHamiltonian</code>. Here it is defined on an <code>L=2</code> dimensional lattice. The subsequent arguments are collections of Bloch phases on each of the <code>L</code> axes of the Brillouin zone, whose direct product <code>ϕ₁points</code> ⊗ <code>ϕ₂points</code> defines our base mesh of <code>ϕᵢ</code> points. Here it is a uniform 19×19 grid. We can once more use <code>qplot</code> to visualize the bandstructure, or more precisely the band meshes:</p><pre><code class="language-julia hljs">julia&gt; using GLMakie; qplot(b)</code></pre><img src="../../assets/graphene_bands.png" alt="Graphene bands" width="400" class="center"/><p>The dots on the bands are the band mesh vertices <code>(ϕᵢ..., eⱼ(ϕᵢ))</code>. They can be omitted with the <code>qplot</code> keyword <code>hide = :nodes</code> (or <code>hide = :vertices</code>, both are equivalent).</p><h2 id="Band-defects"><a class="docs-heading-anchor" href="#Band-defects">Band defects</a><a id="Band-defects-1"></a><a class="docs-heading-anchor-permalink" href="#Band-defects" title="Permalink"></a></h2><p>Note that the uniform grid contains the Dirac points. This is the reason for the number <code>19</code> of Bloch phases used above. Note also that it is identified as a point in the bands with <code>degeneracy = 2</code> (the rest have <code>degeneracy = 1</code>). As mentioned, the points on the bands are connected based on eigenstate overlaps between adjacent <code>ϕᵢ</code>s. This interpolation algorithm can deal with subspace degeneracies, as here. However, Dirac points (and Diabolical Points in general) must belong to the mesh for the method to work. If the number of points is reduced to 18 per axis, the Dirac points become unavoidable band dislocations, that appear as missing simplices in the bands:</p><img src="../../assets/graphene_bands_bad.png" alt="Graphene bands with Dirac point dislocation" width="400" class="center"/><div class="admonition is-success"><header class="admonition-header">Advanced: band defects and patching</header><div class="admonition-body"><p>If a Dirac point or other type of band dislocation point happens to not belong to the sampling grid, it can be added with the <code>bands</code> keyword <code>defects</code>. Then, it can be reconnected with the rest of the band by increasing the <code>patches::Integer</code> keyword (see <code>bands</code> docstring for details). This &quot;band repair&quot; functionality is experimental, and should only be necessary in some cases with Diabolical Points.</p></div></div><h2 id="Coordinate-mapping-and-band-linecuts"><a class="docs-heading-anchor" href="#Coordinate-mapping-and-band-linecuts">Coordinate mapping and band linecuts</a><a id="Coordinate-mapping-and-band-linecuts-1"></a><a class="docs-heading-anchor-permalink" href="#Coordinate-mapping-and-band-linecuts" title="Permalink"></a></h2><p>The direct product of the <code>ϕᵢpoints</code> above define a rectangular mesh over which we want to compute the bandstructure. By default, this mesh is taken as a discretization of Bloch phases, so <code>h(ϕᵢ)</code> is diagonalized at each point of the base mesh. We might want, however, a different relation between the mesh and the parameters passed to <code>h</code>, for example if we wish to use wavevectors <code>k</code> instead of Bloch phases <code>ϕᵢ = k⋅Aᵢ</code> for the mesh. This is achieved with the <code>mapping</code> keyword, which accepts a function <code>mapping = (mesh_points...) -&gt; bloch_phases</code>,</p><pre><code class="language-julia hljs">julia&gt; h = LP.honeycomb() |&gt; hopping(2); k₁points = range(-2π, 2π, length = 51); k₂points = range(-2π, 2π, length = 51);

julia&gt; Kpoints = [SA[cos(θ) -sin(θ); sin(θ) cos(θ)] * SA[4π/3,0] for θ in range(0, 5*2π/6, length = 6)];

julia&gt; ϕ(k...) =  SA[k...]&#39; * bravais_matrix(h)
ϕ (generic function with 1 method)

julia&gt; b = bands(h,  k₁points, k₂points; mapping = ϕ, defects = Kpoints, patches = 20);

julia&gt; using GLMakie; qplot(b, hide = (:nodes, :wireframe), color = :orange)</code></pre><img src="../../assets/graphene_bands_k.png" alt="Graphene bands in k-space" width="400" class="center"/><p>To compute a bandstructure linecut along a polygonal line in the Brillouin zone, we could once more use the <code>mapping</code> functionality, mapping a set of points <code>xᵢ::Real</code> in the mesh to Bloch phases <code>ϕᵢ</code> that defines the nodes of the polygonal path, and interpolating linearly between them. To avoid having to construct this mapping ourselves, <code>mapping</code> accepts a second type of input for this specific usecase, <code>mapping = xᵢ =&gt; ϕᵢ</code>. Here, <code>ϕᵢ</code> can be a collection of <code>Tuple</code>s, <code>SVector{L}</code>, or even <code>Symbols</code> denoting common names for high-symmetry points in the Brillouin zone, such as :Γ, :K, :K´, :M, :X, :Y, and :Z. The following gives a Γ-K-M-Γ linecut for the bands above, where the (Γ, K, M, Γ) points lie at <code>x = (0, 2, 3, 4)</code>, respectively, with 10 subdivisions in each segment,</p><pre><code class="language-julia hljs">julia&gt; b = bands(h, subdiv((0, 2, 3, 4), 10); mapping = (0, 2, 3, 4) =&gt; (:Γ, :K, :M, :Γ));

julia&gt; qplot(b, axis = (; xticks = ([0, 2, 3, 4], [&quot;Γ&quot;, &quot;K&quot;, &quot;M&quot;, &quot;Γ&quot;]), ylabel = &quot;ϵ&quot;))</code></pre><img src="../../assets/graphene_bands_linecut.png" alt="Graphene bands along a Γ-K-M-Γ cut" width="400" class="center"/><div class="admonition is-success"><header class="admonition-header">subdiv</header><div class="admonition-body"><p>The <code>subdiv</code> function is a convenience function provided by Quantica.jl that generalizes <code>range</code> (see the corresponding docstring for comprehensive details). It is useful to create collections of numbers as subdivisions of intervals, as in the example above. In its simplest form <code>subdiv(min, max, npoints)</code> is is equivalent to <code>range(min, max, npoints)</code>.</p></div></div><p>The <code>mapping</code> keyword understand a third syntax that can be used to map a mesh to the space of Bloch phases and parameters of a <code>ParametricHamiltonian</code>. To this end we use <code>mapping = (mesh_points...) -&gt; ftuple(bloch_phases...; params...)</code>. The <code>ftuple</code> function creates a <code>FrankenTuple</code>, which is a hybrid between a <code>Tuple</code> and a <code>NamedTuple</code>. For example, in the following 1D SSH chain we can compute the bandstructure as a function of Bloch phase <code>ϕ</code> <em>and</em> hopping <code>t´</code>, and plot it using more customization options</p><pre><code class="language-julia hljs">julia&gt; h = LP.linear() |&gt; supercell(2) |&gt; @hopping((r, dr; t = 1, t´ = 2) -&gt; iseven(r[1]-1/2) ? t : t´);

julia&gt; b = bands(h, subdiv(0, 2π, 11), subdiv(0, 10, 11), mapping = (ϕ, y) -&gt; ftuple(ϕ; t´ = y/5), patches = 20)
Bandstructure{Float64,3,2}: 3D Bandstructure over a 2-dimensional parameter space of type Float64
  Subbands  : 1
  Vertices  : 249
  Edges     : 664
  Simplices : 416

julia&gt; qplot(b, nodedarken = 0.5, axis = (; aspect = (1,1,1), perspectiveness = 0.5, xlabel = &quot;ϕ&quot;, ylabel = &quot;t´/t&quot;, zlabel = &quot;ϵ&quot;), fancyaxis = false)</code></pre><img src="../../assets/ssh_bands.png" alt="SSH bandstructure as a function of `ϕ` and `t´/t" width="400" class="center"/><p>Note that since we didn&#39;t specify a value for <code>t</code>, it assumed its default <code>t=1</code>. In this case we needed to patch the defect at <code>(ϕ, t´) = (π, 1)</code> (topological transition) using the <code>patches</code> keyword to avoid a band dislocation.</p><p>If no parameters are specified or mapped, they take their default values. For example, this produces the 1D bandstructure of the SSH model for the default <code>t = 1, t´ = 2</code> over the default 1D mesh (49 points, uniformly distributed in <code>[-π, π]</code>)</p><pre><code class="language-julia hljs">julia&gt; qplot(bands(h))</code></pre><img src="../../assets/ssh_bands_1D.png" alt="SSH 1D bandstructure as a function of `ϕ` for `t´ = 2t = 2" width="500" class="center"/><div class="admonition is-success"><header class="admonition-header">Experimental `Quantica.gaps` and `Quantica.decay_lengths` for 1D Hamiltonians</header><div class="admonition-body"><p>The function <code>Quantica.gaps(h, µ)</code> can be used to efficiently calculate the gaps respect to chemical potential <code>µ</code> at local band minima, but only for 1D <code>Hamiltonian</code>&#39;s for the moment. Similarly <code>Quantica.decay_lengths(h, µ; reverse = false)</code> will yield the decay lengths of the evanescent modes of <code>h</code> at energy <code>µ</code> (towards the positive direction, unless <code>reverse = true</code>). Both functions are unexported and experimental.</p></div></div><h2 id="Band-indexing-and-slicing"><a class="docs-heading-anchor" href="#Band-indexing-and-slicing">Band indexing and slicing</a><a id="Band-indexing-and-slicing-1"></a><a class="docs-heading-anchor-permalink" href="#Band-indexing-and-slicing" title="Permalink"></a></h2><p>The individual subbands in a given <code>b::Bandstructure</code> can be obtained with <code>b[inds]</code> with <code>inds::Integer</code> or <code>inds::Vector</code>, just as if <code>b</code> where a normal <code>AbstractVector</code>. The extracted subbands can also be plotted directly. The following example has 12 subbands, of which we extract and plot the first and last</p><pre><code class="language-julia hljs">julia&gt; h = LP.triangular() |&gt; supercell(4) |&gt; hopping(1) + onsite(r -&gt; 4*rand());

julia&gt; b = bands(h, subdiv(0, 2π, 31), subdiv(0, 2π, 31))
Bandstructure{Float64,3,2}: 3D Bandstructure over a 2-dimensional parameter space of type Float64
  Subbands  : 12
  Vertices  : 15376
  Edges     : 44152
  Simplices : 28696

julia&gt; qplot(b, hide = (:nodes, :wireframe))

julia&gt; qplot(b[[1, end]], hide = (:nodes, :wireframe))</code></pre><img src="../../assets/bands_indexed.png" alt="Extracting and plotting a subset of the subbands in a bandstructure" width="600" class="center"/><p>For a band in a 2D Brillouin zone, we can also obtain the intersection of a bandstructure with a plane of constant energy <code>ϵ=2</code> using the syntax <code>b[(:,:,2)]</code>. A section at fixed Bloch phase <code>ϕ₁=0</code> (or mesh coordinate <code>x₁=0</code> if <code>mapping</code> was used), can be obtained with <code>b[(0,:,:)]</code>. This type of band slicing can be generalized to higher dimensional bandstructures, or to more than one constrain (e.g. energy and/or a subset of Bloch phases). As an example, this would be the Fermi surface of a nearest-neighbor cubic-lattice Hamiltonian at Fermi energy <code>µ = 0.2t</code></p><pre><code class="language-julia hljs">julia&gt; pts = subdiv(0, 2π, 41); b = LP.cubic() |&gt; hopping(1) |&gt; bands(pts, pts, pts)
Bandstructure{Float64,4,3}: 4D Bandstructure over a 3-dimensional parameter space of type Float64
  Subbands  : 1
  Vertices  : 68921
  Edges     : 462520
  Simplices : 384000

julia&gt; qplot(b[(:, :, :, 0.2)], hide = (:nodes, :wireframe))</code></pre><img src="../../assets/cubic_Fermi_surface.png" alt="Fermi surface of a cubic crystal at `µ = 0.2t`" width="400" class="center"/><div class="admonition is-warning"><header class="admonition-header">On simplex orientation of bandstructure slices</header><div class="admonition-body"><p>The above example showcases a current (cosmetic) limitation of the band slicing algorithm: it sometimes fails to align all faces of the resulting manifold to the same orientation. The dark and bright regions of the surface above reveals that approximately half of the faces in this case are facing inward and the rest outward.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../hamiltonians/">« Hamiltonians</a><a class="docs-footer-nextpage" href="../greenfunctions/">GreenFunctions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 12 December 2024 19:47">Thursday 12 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
