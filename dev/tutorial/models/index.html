<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Models · Quantica.jl</title><meta name="title" content="Models · Quantica.jl"/><meta property="og:title" content="Models · Quantica.jl"/><meta property="twitter:title" content="Models · Quantica.jl"/><meta name="description" content="Documentation for Quantica.jl."/><meta property="og:description" content="Documentation for Quantica.jl."/><meta property="twitter:description" content="Documentation for Quantica.jl."/><meta property="og:url" content="https://pablosanjose.github.io/Quantica.jl/tutorial/models/"/><meta property="twitter:url" content="https://pablosanjose.github.io/Quantica.jl/tutorial/models/"/><link rel="canonical" href="https://pablosanjose.github.io/Quantica.jl/tutorial/models/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Quantica.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Quantica.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Quantica.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../tutorial/">Welcome</a></li><li><a class="tocitem" href="../glossary/">Glossary</a></li><li><a class="tocitem" href="../lattices/">Lattices</a></li><li class="is-active"><a class="tocitem" href>Models</a><ul class="internal"><li><a class="tocitem" href="#HopSelectors"><span>HopSelectors</span></a></li><li><a class="tocitem" href="#Parametric-Models"><span>Parametric Models</span></a></li><li><a class="tocitem" href="#Modifiers"><span>Modifiers</span></a></li></ul></li><li><a class="tocitem" href="../hamiltonians/">Hamiltonians</a></li><li><a class="tocitem" href="../bandstructures/">Bandstructures</a></li><li><a class="tocitem" href="../greenfunctions/">GreenFunctions</a></li><li><a class="tocitem" href="../observables/">Observables</a></li></ul></li><li><span class="tocitem">Advanced</span><ul><li><a class="tocitem" href="../../advanced/nonspatial/">Non-spatial models</a></li><li><a class="tocitem" href="../../advanced/serializers/">Serializers</a></li><li><a class="tocitem" href="../../advanced/meanfield/">Self-consistent mean fields</a></li><li><a class="tocitem" href="../../advanced/wannier90/">Wannier90 imports</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Models</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/pablosanjose/Quantica.jl/blob/master/docs/src/tutorial/models.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h1><p>We now will show how to build a generic single-particle tight-binding model, with generic Hamiltonian</p><p><span>$H = \sum_{i\alpha j\beta} c_{i\alpha}^\dagger V_{\alpha\beta}(r_i, r_j)c_{j\alpha}$</span></p><p>Here, <code>α,β</code> are orbital indices in each site, <code>i,j</code> are site indices, and <code>rᵢ, rⱼ</code> are site positions. In Quantica.jl we would write the above model as</p><pre><code class="language-julia hljs">julia&gt; model = onsite(r -&gt; V(r, r)) + hopping((r, dr) -&gt; V(r-dr/2, r+dr/2))
TightbindingModel: model with 2 terms
  OnsiteTerm{Function}:
    Region            : any
    Sublattices       : any
    Cells             : any
    Coefficient       : 1
  HoppingTerm{Function}:
    Region            : any
    Sublattice pairs  : any
    Cell distances    : any
    Hopping range     : Neighbors(1)
    Reverse hops      : false
    Coefficient       : 1</code></pre><p>where <code>V(rᵢ, rⱼ)</code> is a function that returns a matrix (ideally an <code>SMatrix</code>) <span>$V_{\alpha\beta}(r_i, r_j)$</span> of the required orbital dimensionality.</p><p>Note that when writing models we distinguish between onsite (<code>rᵢ=rⱼ</code>) and hopping (<code>rᵢ≠rⱼ</code>) terms. For the former, <code>r</code> is the site position. For the latter we use a bond-center and bond-distance <code>(r, dr)</code> parametrization of <code>V</code>, so that <code>r₁, r₂ = r ∓ dr/2</code></p><p>If the onsite and hopping amplitudes do not depend on position, we can simply use constants</p><pre><code class="language-julia hljs">julia&gt; model = onsite(1) - 2*hopping(1)
TightbindingModel: model with 2 terms
  OnsiteTerm{Int64}:
    Region            : any
    Sublattices       : any
    Cells             : any
    Coefficient       : 1
  HoppingTerm{Int64}:
    Region            : any
    Sublattice pairs  : any
    Cell distances    : any
    Hopping range     : Neighbors(1)
    Reverse hops      : false
    Coefficient       : -2</code></pre><div class="admonition is-success"><header class="admonition-header">Model term algebra</header><div class="admonition-body"><p>Note that we can combine model terms as in the above example by summing and subtracting them, and using constant coefficients.</p></div></div><h2 id="HopSelectors"><a class="docs-heading-anchor" href="#HopSelectors">HopSelectors</a><a id="HopSelectors-1"></a><a class="docs-heading-anchor-permalink" href="#HopSelectors" title="Permalink"></a></h2><p>By default <code>onsite</code> terms apply to any site in a Lattice, and <code>hopping</code> terms apply to any pair of sites within nearest-neighbor distance (see the <code>Hopping range: Neighbors(1)</code> above).</p><p>We can change this default by specifying a <code>SiteSelector</code> or <code>HopSelector</code> for each term. <code>SiteSelector</code>s where <a href="../lattices/#siteselectors">already introduced</a> to create <code>LatticeSlices</code>. <code>HopSelectors</code> are very similar, but support slightly different keywords:</p><ul><li><code>region</code>: to restrict according to bond center <code>r</code> and bond vector <code>dr</code></li><li><code>sublats</code>: to restrict source and target sublattices</li><li><code>dcells</code>: to restrict the distance in cell index</li><li><code>range</code>: to restrict the distance in real space</li></ul><p>As an example, a <code>HopSelector</code> that selects any two sites at a distance between <code>1.0</code> and the second-nearest neighbor distance, with the first belonging to sublattice <code>:B</code> and the second to sublattice <code>:A</code>, and their bond center inside a unit circle</p><pre><code class="language-julia hljs">julia&gt; hs = hopselector(range = (1.0, neighbors(2)), sublats = :B =&gt; :A, region = (r, dr) -&gt; norm(r) &lt; 1)
HopSelector: a rule that defines a finite collection of hops between sites in a lattice
  Region            : Function
  Sublattice pairs  : :B =&gt; :A
  Cell distances    : any
  Hopping range     : (1.0, Neighbors(2))
  Reverse hops      : false</code></pre><p>We can now use this <code>HopSelector</code> to restrict the hoppings in a model, just as <code>SiteSelector</code>s can be used to restrict onsite terms</p><pre><code class="language-julia hljs">julia&gt; model = plusadjoint(hopping(1, hs)) - 2*onsite(1, sublats = :B)
TightbindingModel: model with 3 terms
  HoppingTerm{Int64}:
    Region            : Function
    Sublattice pairs  : :B =&gt; :A
    Cell distances    : any
    Hopping range     : (1.0, Neighbors(2))
    Reverse hops      : false
    Coefficient       : 1
  HoppingTerm{Int64}:
    Region            : Function
    Sublattice pairs  : :B =&gt; :A
    Cell distances    : any
    Hopping range     : (1.0, Neighbors(2))
    Reverse hops      : true
    Coefficient       : 1
  OnsiteTerm{Int64}:
    Region            : any
    Sublattices       : B
    Cells             : any
    Coefficient       : 1</code></pre><p>Note that we can pass the <code>Selector</code> itself as a second argument to <code>hopping</code> and <code>onsite</code>, or alternatively use selector keywords directly as in the <code>onsite</code> above.</p><div class="admonition is-success"><header class="admonition-header">plusadjoint function</header><div class="admonition-body"><p>The convenience function <code>plusadjoint(term) = term + term&#39;</code> adds the Hermitian conjugate of its argument (<code>term&#39;</code>), equivalent to the <code>+ h.c.</code> notation often used in the literature.</p></div></div><div class="admonition is-info"><header class="admonition-header">Index-agnostic modeling</header><div class="admonition-body"><p>The Quantica.jl approach to defining tight-binding models does not rely explicitly on site indices (<code>i,j</code> above), since these are arbitrary, and may even be beyond the control of the user (for example after using <code>supercell</code>). Instead, we rely on physical properties of sites, such as position, distance or sublattice.</p></div></div><h2 id="Parametric-Models"><a class="docs-heading-anchor" href="#Parametric-Models">Parametric Models</a><a id="Parametric-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-Models" title="Permalink"></a></h2><p>The models introduced above are non-parametric, in the sense that they encode fixed, numerical Hamiltonian matrix elements. In many problems, it is commonplace to have models that depend on a number of free parameters that will need to be adjusted during a calculation. For example, one may need to compute the phase diagram of a system as a function of a spin-orbit coupling or an applied magnetic field. For these cases, we have <code>ParametricModel</code>s.</p><p>Parametric models are defined with</p><ul><li><code>@onsite((; params...) -&gt; ...; sites...)</code></li><li><code>@onsite((r; params...) -&gt; ...; sites...)</code></li><li><code>@hopping((; params...) -&gt; ...; hops...)</code></li><li><code>@hopping((r, dr; params...) -&gt; ...; hops...)</code></li></ul><p>where the <code>params</code> keyword arguments define the free parameters, together with (optional) default values. Here is an example of a hopping model with a Peierls phase in the symmetric gauge, with the magnetic field <code>Bz</code> and the zero-field hopping <code>t</code> as free parameters</p><pre><code class="language-julia hljs">julia&gt; model_perierls = @hopping((r, dr; Bz = 0, t = 1) -&gt; t * cis(-im * Bz/2 * SA[-r[2], r[1], 0]&#39; * dr))
ParametricModel: model with 1 term
  ParametricHoppingTerm{ParametricFunction{2}}
    Region            : any
    Sublattice pairs  : any
    Cell distances    : any
    Hopping range     : Neighbors(1)
    Reverse hops      : false
    Coefficient       : 1
    Argument type     : spatial
    Parameters        : [:Bz, :t]</code></pre><p>One can linearly combine parametric and non-parametric models freely, omit parameter default values, and use any of the functional argument forms described for <code>onsite</code> and <code>hopping</code> (although not the constant argument form):</p><pre><code class="language-julia hljs">julia&gt; model´ = 2 * (onsite(1) - 2 * @hopping((; t) -&gt; t))
ParametricModel: model with 2 terms
  ParametricHoppingTerm{ParametricFunction{0}}
    Region            : any
    Sublattice pairs  : any
    Cell distances    : any
    Hopping range     : Neighbors(1)
    Reverse hops      : false
    Coefficient       : -4
    Argument type     : spatial
    Parameters        : [:t]
  OnsiteTerm{Int64}:
    Region            : any
    Sublattices       : any
    Cells             : any
    Coefficient       : 2</code></pre><div class="admonition is-success"><header class="admonition-header">Non-spatial parametric models with --&gt;</header><div class="admonition-body"><p>The <code>-&gt;</code> in the above parametric models <code>@onsite</code> and <code>@hopping</code>, but also in the modifiers below, can be changed to <code>--&gt;</code>. This indicates that the function arguments are no longer treated as site or link positions <code>r</code> and <code>dr</code>, but as objects <code>i, j</code> representing destination and source sites. This allows to address sites directly instead of through their spatial location. See the Mean Field section for further details.</p></div></div><h2 id="Modifiers"><a class="docs-heading-anchor" href="#Modifiers">Modifiers</a><a id="Modifiers-1"></a><a class="docs-heading-anchor-permalink" href="#Modifiers" title="Permalink"></a></h2><p>There is a third model-related functionality known as <code>OnsiteModifier</code>s and <code>HoppingModifier</code>s. Given a model that defines a set of onsite and hopping amplitudes on a subset of sites and hops, one can define a parameter-dependent modification of a subset of said amplitudes. This is a useful way to introduce a new parameter dependence on an already defined model. Modifiers are built with</p><ul><li><code>@onsite!((o; params...) -&gt; new_onsite; sites...)</code></li><li><code>@onsite!((o, r; params...) -&gt; new_onsite; sites...)</code></li><li><code>@hopping((t; params...) -&gt; new_hopping; hops...)</code></li><li><code>@hopping((t, r, dr; params...) -&gt; new_hopping; hops...)</code></li></ul><p>where the first argument <code>o</code> and <code>t</code> is the unmodified value of the onsite or hopping amplitude, respectively. Here <code>sites</code> and <code>hops</code> are once more keyword arguments to restrict the modification with a <code>SiteSelector</code> or <code>HopSelector</code>.</p><p>For example, the following <code>HoppingModifier</code> inserts a Peierls phase on all the hopping in a given model</p><pre><code class="language-julia hljs">julia&gt; model_perierls! = @hopping!((t, r, dr; B = 0) -&gt; t * cis(-Bz/2 * SA[-r[2], r[1], 0]&#39; * dr))
HoppingModifier{ParametricFunction{3}}:
  Region            : any
  Sublattice pairs  : any
  Cell distances    : any
  Hopping range     : Inf
  Reverse hops      : false
  Argument type     : spatial
  Parameters        : [:B]</code></pre><p>The difference with <code>model_perierls</code> is that <code>model_perierls!</code> will never add any new hoppings. It will only modify previously existing hoppings in a model. Modifiers are not models themselves, and cannot be summed to other models. They are instead meant to be applied sequentially after applying a model.</p><p>In the next section we show how models and modifiers can be used in practice to construct Hamiltonians.</p><div class="admonition is-info"><header class="admonition-header">Mind the `;`</header><div class="admonition-body"><p>While syntax like <code>onsite(2, sublats = :B)</code> and <code>onsite(2; sublats = :B)</code> are equivalent in Julia, due to the way keyword arguments are parsed, the same is not true for macro calls like <code>@onsite</code>, <code>@onsite!</code>, <code>@hopping</code> and <code>@hopping!</code>. These macros just emulate the function call syntax. But to work you must currently always use the <code>;</code> separator for keywords. Hence, something like <code>@onsite((; p) -&gt; p; sublats = :B)</code> works, but <code>@onsite((; p) -&gt; p, sublats = :B)</code> does not.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lattices/">« Lattices</a><a class="docs-footer-nextpage" href="../hamiltonians/">Hamiltonians »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Sunday 4 May 2025 09:00">Sunday 4 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
